<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Jugadas Rugby - Los Troncos</title>

    <!-- Bootstrap 4 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <style>
        body {
            background: #f4f6f9;
            font-family: 'Source Sans Pro', sans-serif;
        }

        .navbar-rugby {
            background: linear-gradient(135deg, #1e4d2b 0%, #28a745 100%);
            color: white;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .navbar-rugby h3 {
            margin: 0;
            color: white;
            font-weight: 600;
        }

        .canvas-container {
            border: 3px solid #1e4d2b !important;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn-rugby {
            background: #1e4d2b;
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-rugby:hover {
            background: #28a745;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-rugby i {
            margin-right: 0.5rem;
        }

        .tools-panel {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }

        .tools-panel .btn {
            font-size: 0.85rem;
            padding: 0.4rem 0.6rem;
        }

        .tools-panel .form-control {
            font-size: 0.85rem;
        }

        .tools-panel optgroup {
            font-weight: 600;
            font-style: normal;
        }

        .tools-panel option {
            padding-left: 0.5rem;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .section-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: #1e4d2b;
            margin-top: 0.75rem;
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            border-bottom: 2px solid #1e4d2b;
            padding-bottom: 0.2rem;
        }

        .section-header:first-child {
            margin-top: 0;
        }

        .section-header i {
            font-size: 0.7rem;
        }

        #playNameInput, #formacionSelect {
            border: 2px solid #dee2e6;
            border-radius: 6px;
            transition: border-color 0.3s;
        }

        #playNameInput:focus, #formacionSelect:focus {
            border-color: #1e4d2b;
            box-shadow: 0 0 0 0.2rem rgba(30, 77, 43, 0.15);
        }

        .saved-play-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.4rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .saved-play-item:hover {
            background: #e9ecef;
            border-color: #1e4d2b;
            transform: translateX(3px);
        }

        .saved-play-item strong {
            color: #1e4d2b;
            font-size: 0.85rem;
        }

        .saved-play-item small {
            font-size: 0.7rem;
        }

        .saved-play-item .btn-sm {
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
        }

        .badge-rugby {
            background: #1e4d2b;
        }

        .alert-info-rugby {
            background: #d4edda;
            border: 1px solid #1e4d2b;
            color: #155724;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <div class="navbar-rugby">
        <div class="container-fluid">
            <h3>
                <i class="fas fa-chalkboard-teacher"></i>
                Editor de Jugadas Rugby - Los Troncos (FASE 1: Posiciones Fijas)
            </h3>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container-fluid">
        <div class="row">
            <!-- Canvas Area -->
            <div class="col-md-10">
                <div class="canvas-wrapper">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">
                            <i class="fas fa-football-ball"></i> Cancha de Rugby
                            <small class="text-muted">(Ataque: Izquierda ‚Üí Derecha)</small>
                        </h4>
                        <button id="btnClearCanvas" class="btn btn-danger btn-sm">
                            <i class="fas fa-trash"></i> Limpiar Todo
                        </button>
                    </div>
                    <canvas id="playCanvas" width="1200" height="650"></canvas>
                </div>
            </div>

            <!-- Tools Panel -->
            <div class="col-md-2">
                <!-- Info Alert -->
                <div class="alert-info-rugby">
                    <i class="fas fa-info-circle"></i>
                    <strong>Fase 1:</strong> Posiciones fijas. Arrastra para mover.
                </div>

                <!-- Panel 1: Agregar Jugadores -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-user-plus"></i> Jugadores
                    </div>
                    <button id="btnAddForward" class="btn btn-rugby btn-block mb-2">
                        <i class="fas fa-user"></i> Forward
                    </button>
                    <button id="btnAddBack" class="btn btn-rugby btn-block mb-2">
                        <i class="fas fa-running"></i> Back
                    </button>
                    <button id="btnAddBall" class="btn btn-warning btn-block mb-2">
                        üèà Bal√≥n
                    </button>
                    <button id="btnAssignPossession" class="btn btn-outline-warning btn-block mb-2" disabled>
                        <i class="fas fa-hand-holding"></i> Asignar posesi√≥n
                    </button>
                    <button id="btnReleasePossession" class="btn btn-outline-secondary btn-block mb-2" style="display: none;">
                        <i class="fas fa-hand-paper"></i> Soltar bal√≥n
                    </button>
                    <button id="btnDeleteSelected" class="btn btn-danger btn-block">
                        <i class="fas fa-trash-alt"></i> Eliminar
                    </button>
                </div>

                <!-- Panel 2: Trayectorias -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-route"></i> Trayectorias
                    </div>
                    <button id="btnDrawMovement" class="btn btn-info btn-block mb-2" disabled>
                        <i class="fas fa-pencil-alt"></i> Dibujar movimiento
                    </button>
                    <button id="btnCreatePass" class="btn btn-primary btn-block mb-2" disabled>
                        üîó Crear Pase
                    </button>
                    <div class="btn-group btn-block mb-2" role="group">
                        <button id="btnPlay" class="btn btn-success" disabled>
                            <i class="fas fa-play"></i> Play
                        </button>
                        <button id="btnReset" class="btn btn-secondary">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                    <button id="btnClearMovements" class="btn btn-outline-danger btn-block btn-sm">
                        <i class="fas fa-eraser"></i> Borrar trayectorias
                    </button>
                    <small id="animationStatus" class="text-muted d-block mt-2">
                        <i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero
                    </small>
                </div>

                <!-- Panel 3: Formaciones -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-users"></i> Formaciones
                    </div>
                    <select id="formacionSelect" class="form-control form-control-sm mb-2">
                        <option value="">-- Selecciona --</option>
                        <optgroup label="üü£ Forwards">
                            <option value="scrum">Scrum</option>
                            <option value="lineout">Lineout 5</option>
                            <option value="lineout_completo">Lineout completo</option>
                            <option value="ruck">Ruck</option>
                            <option value="maul">Maul</option>
                        </optgroup>
                        <optgroup label="üü¢ Backs">
                            <option value="backs">Backs l√≠nea ataque</option>
                        </optgroup>
                        <optgroup label="üü° Situaciones Especiales">
                            <option value="kickoff">Kick-off (recepci√≥n)</option>
                        </optgroup>
                        <optgroup label="‚ö™ Equipo Completo">
                            <option value="full15">15 jugadores</option>
                        </optgroup>
                    </select>
                    <button id="btnApplyFormacion" class="btn btn-rugby btn-block btn-sm">
                        <i class="fas fa-check-circle"></i> Aplicar
                    </button>
                </div>

                <!-- Panel 3: Guardar -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-save"></i> Guardar
                    </div>
                    <input type="text" id="playNameInput" class="form-control form-control-sm mb-2"
                           placeholder="Nombre...">
                    <select id="playCategory" class="form-control form-control-sm mb-2">
                        <option value="forwards">üü£ Forwards</option>
                        <option value="backs">üü¢ Backs</option>
                        <option value="full_team">‚ö™ Equipo completo</option>
                    </select>
                    <button id="btnSavePlay" class="btn btn-rugby btn-block btn-sm">
                        <i class="fas fa-save"></i> Guardar
                    </button>
                </div>

                <!-- Panel 4: Jugadas Guardadas -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-folder-open"></i> Guardadas
                        <span class="badge badge-rugby float-right" id="playCount">0</span>
                    </div>
                    <div id="savedPlaysList" style="max-height: 250px; overflow-y: auto;">
                        <p class="text-muted text-center small mb-0">
                            <i class="fas fa-info-circle"></i> Sin jugadas
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // ============================================
        // üèâ RUGBY PLAY EDITOR - FASE 1
        // Sistema simple de posiciones fijas
        // ============================================

        const canvas = new fabric.Canvas('playCanvas', {
            backgroundColor: '#2d5a2d',
            selection: true
        });

        let playerCounter = 1;
        let players = [];
        let selectedPlayer = null;
        let rugbyBall = null;  // Variable para el bal√≥n

        // Variables para sistema de trayectorias
        let movements = [];           // Array de todos los movimientos
        let isDrawingMode = false;    // Modo dibujo activo
        let currentPath = [];         // Puntos del trazo actual
        let selectedForDrawing = null; // Objeto seleccionado para dibujar

        // Variables para sistema de animaci√≥n
        let originalPositions = {};      // Posiciones iniciales {playerId: {left, top}}
        let isPlaying = false;           // Estado de reproducci√≥n
        let currentAnimationIndex = 0;   // √çndice del movimiento actual

        // Variables para sistema de posesi√≥n del bal√≥n
        let ballPossession = null;       // ID del jugador que tiene el bal√≥n (null = libre)
        let isAssigningPossession = false; // Modo asignaci√≥n activo

        // Variables para sistema de pases
        let isCreatingPass = false;      // Modo crear pase activo
        let passFromPlayer = null;       // Jugador origen del pase

        // Offsets globales para posici√≥n del bal√≥n (relativo al jugador)
        const BALL_OFFSET_X = 30;
        const BALL_OFFSET_Y = 0;

        // ============================================
        // 1. CARGAR CANCHA DE RUGBY EN EL CANVAS
        // ============================================
        function drawRugbyField() {
            fabric.Image.fromURL('cancha_rugby.png', function(img) {
                // Configurar la imagen para que cubra todo el canvas
                img.set({
                    left: 0,
                    top: 0,
                    scaleX: canvas.width / img.width,
                    scaleY: canvas.height / img.height,
                    selectable: false,
                    evented: false,
                    hasControls: false,
                    hasBorders: false
                });

                // Agregar como primer objeto (estar√° en el fondo)
                canvas.add(img);
                img.sendToBack();

                canvas.renderAll();
                console.log('‚úÖ Cancha de rugby cargada en canvas');
            });
        }

        // ============================================
        // 2. AGREGAR JUGADORES
        // ============================================
        function addPlayer(type, x = null, y = null, num = null) {
            const color = type === 'forward' ? '#1e4d2b' : '#28a745';
            const playerNum = num !== null ? num : playerCounter;

            // C√≠rculo del jugador con sombra
            const circle = new fabric.Circle({
                radius: 20,
                fill: color,
                stroke: 'white',
                strokeWidth: 3,
                originX: 'center',
                originY: 'center',
                shadow: new fabric.Shadow({
                    color: 'rgba(0, 0, 0, 0.8)',
                    blur: 10,
                    offsetX: 2,
                    offsetY: 2
                })
            });

            // N√∫mero del jugador
            const text = new fabric.Text(playerNum.toString(), {
                fontSize: 18,
                fill: 'white',
                fontWeight: 'bold',
                originX: 'center',
                originY: 'center'
            });

            // Grupo (c√≠rculo + texto)
            const player = new fabric.Group([circle, text], {
                left: x !== null ? x : 300 + Math.random() * 400,
                top: y !== null ? y : 200 + Math.random() * 200,
                hasControls: false,
                hasBorders: true,
                borderColor: '#ffeb3b',
                borderScaleFactor: 3,
                cornerColor: color,
                transparentCorners: false,
                lockRotation: true,
                playerType: type,
                playerNumber: playerNum,
                isPlayer: true
            });

            // Event: Selecci√≥n
            player.on('selected', function() {
                selectedPlayer = player;
            });

            canvas.add(player);
            players.push(player);

            if (num === null) {
                playerCounter++;
            }

            canvas.renderAll();
            return player;
        }

        // ============================================
        // 2.5 AGREGAR BAL√ìN DE RUGBY
        // ============================================
        function crearBalon(x = 600, y = 325) {
            // Si ya existe un bal√≥n, no crear otro
            if (rugbyBall) {
                alert('‚ö†Ô∏è Ya existe un bal√≥n en la cancha');
                return null;
            }

            // Crear elipse (forma de bal√≥n de rugby inclinado)
            const ball = new fabric.Ellipse({
                rx: 15,  // radio horizontal
                ry: 10,  // radio vertical
                fill: '#FFD700',  // amarillo
                stroke: '#8B4513',  // marr√≥n
                strokeWidth: 2,
                left: x,
                top: y,
                angle: -30,  // inclinaci√≥n del bal√≥n
                originX: 'center',
                originY: 'center',
                hasControls: false,
                hasBorders: true,
                borderColor: '#FF0000',
                borderScaleFactor: 3,
                lockRotation: true,
                isBall: true,  // identificador
                shadow: new fabric.Shadow({
                    color: 'rgba(0, 0, 0, 0.5)',
                    blur: 8,
                    offsetX: 2,
                    offsetY: 2
                })
            });

            canvas.add(ball);
            rugbyBall = ball;
            canvas.renderAll();

            // Actualizar UI de posesi√≥n
            updatePossessionUI();

            console.log('üèà Bal√≥n agregado en:', x, y);
            return ball;
        }

        function eliminarBalon() {
            if (rugbyBall) {
                // Limpiar posesi√≥n primero
                clearPossession();

                canvas.remove(rugbyBall);
                rugbyBall = null;
                canvas.renderAll();

                // Actualizar UI
                updatePossessionUI();

                console.log('üèà Bal√≥n eliminado');
            }
        }

        // ============================================
        // 2.6 SISTEMA DE TRAYECTORIAS/MOVIMIENTOS
        // ============================================

        // Activar modo dibujo
        function activateDrawingMode() {
            const activeObject = canvas.getActiveObject();

            if (!activeObject || (!activeObject.isPlayer && !activeObject.isBall)) {
                alert('‚ö†Ô∏è Selecciona un jugador o bal√≥n primero');
                return;
            }

            selectedForDrawing = activeObject;
            isDrawingMode = true;
            currentPath = [];

            // Cambiar cursor y estilo del canvas
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';
            canvas.selection = false;

            // Cambiar estilo del bot√≥n
            $('#btnDrawMovement').removeClass('btn-info').addClass('btn-warning')
                .html('<i class="fas fa-times"></i> Cancelar dibujo');

            console.log('‚úèÔ∏è Modo dibujo activado para:',
                activeObject.isBall ? 'Bal√≥n' : `Jugador ${activeObject.playerNumber}`);
        }

        // Desactivar modo dibujo
        function deactivateDrawingMode() {
            isDrawingMode = false;
            currentPath = [];
            selectedForDrawing = null;

            // Restaurar cursor y canvas
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';
            canvas.selection = true;

            // Restaurar estilo del bot√≥n
            const hasSelection = canvas.getActiveObject();
            $('#btnDrawMovement').removeClass('btn-warning').addClass('btn-info')
                .html('<i class="fas fa-pencil-alt"></i> Dibujar movimiento')
                .prop('disabled', !hasSelection);

            canvas.renderAll();
        }

        // Obtener color seg√∫n tipo de objeto
        function getPathColor(obj) {
            if (obj.isBall) return '#FF8C00';  // Naranja para bal√≥n
            if (obj.playerType === 'forward') return '#1e4d2b';  // Verde oscuro
            return '#28a745';  // Verde claro para backs
        }

        // Dibujar el path con flecha
        function createPathWithArrow(points, color) {
            if (points.length < 2) return null;

            // Crear string del path SVG
            let pathString = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                pathString += ` L ${points[i].x} ${points[i].y}`;
            }

            // Crear el path principal
            const path = new fabric.Path(pathString, {
                fill: null,
                stroke: color,
                strokeWidth: 3,
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                selectable: false,
                evented: false,
                opacity: 0.8
            });

            // Calcular √°ngulo para la flecha (√∫ltimos 2 puntos)
            const lastPoint = points[points.length - 1];
            const prevPoint = points[points.length - 2];
            const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x) * 180 / Math.PI;

            // Crear tri√°ngulo de la flecha
            const arrowHead = new fabric.Triangle({
                left: lastPoint.x,
                top: lastPoint.y,
                width: 12,
                height: 15,
                fill: color,
                angle: angle + 90,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false
            });

            // Agrupar path y flecha
            const group = new fabric.Group([path, arrowHead], {
                selectable: false,
                evented: false,
                isMovement: true  // Identificador
            });

            return group;
        }

        // Guardar movimiento
        function saveMovement(obj, points, pathObject) {
            // Verificar si el jugador tiene el bal√≥n
            const hasBall = obj.isPlayer && ballPossession === obj.playerNumber;

            const movement = {
                type: 'movement',  // Tipo de acci√≥n (movement o pass)
                playerId: obj.isBall ? 'ball' : obj.playerNumber,
                playerType: obj.isBall ? 'ball' : obj.playerType,
                points: points.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
                hasBall: hasBall,
                pathObject: pathObject
            };

            movements.push(movement);
            console.log('üíæ Movimiento guardado:', movement.playerId,
                `(${points.length} puntos)`, hasBall ? 'üèà con bal√≥n' : '');

            // Actualizar botones
            updatePlayButton();
            updatePassButton();

            return movement;
        }

        // Limpiar todos los movimientos y pases
        function clearAllMovements() {
            // Remover paths y pases del canvas
            movements.forEach(action => {
                if (action.type === 'movement' && action.pathObject) {
                    canvas.remove(action.pathObject);
                } else if (action.type === 'pass') {
                    if (action.passPath) canvas.remove(action.passPath);
                    if (action.passArrow) canvas.remove(action.passArrow);
                }
            });
            movements = [];
            canvas.renderAll();
            console.log('üßπ Todas las trayectorias y pases eliminados');

            // Actualizar botones
            updatePlayButton();
            updatePassButton();
        }

        // Event handlers para dibujo
        let isMouseDown = false;

        canvas.on('mouse:down', function(opt) {
            if (!isDrawingMode) return;

            const pointer = canvas.getPointer(opt.e);

            // Verificar que empiece cerca del jugador seleccionado
            const objCenter = selectedForDrawing.getCenterPoint();
            const distance = Math.sqrt(
                Math.pow(pointer.x - objCenter.x, 2) +
                Math.pow(pointer.y - objCenter.y, 2)
            );

            if (distance > 60) {
                console.log('‚ö†Ô∏è Comienza m√°s cerca del jugador/bal√≥n');
                return;
            }

            isMouseDown = true;
            currentPath = [{ x: pointer.x, y: pointer.y }];
        });

        canvas.on('mouse:move', function(opt) {
            if (!isDrawingMode || !isMouseDown) return;

            const pointer = canvas.getPointer(opt.e);
            const lastPoint = currentPath[currentPath.length - 1];

            // Solo agregar punto si hay suficiente distancia (suavizado)
            const distance = Math.sqrt(
                Math.pow(pointer.x - lastPoint.x, 2) +
                Math.pow(pointer.y - lastPoint.y, 2)
            );

            if (distance > 8) {
                currentPath.push({ x: pointer.x, y: pointer.y });

                // Dibujar preview temporal
                drawPreviewLine();
            }
        });

        canvas.on('mouse:up', function(opt) {
            if (!isDrawingMode || !isMouseDown) return;

            isMouseDown = false;

            // Limpiar preview
            clearPreviewLine();

            // Verificar longitud m√≠nima
            if (currentPath.length < 3) {
                console.log('‚ö†Ô∏è Trazo muy corto, no guardado');
                deactivateDrawingMode();
                return;
            }

            // Calcular longitud total del trazo
            let totalLength = 0;
            for (let i = 1; i < currentPath.length; i++) {
                totalLength += Math.sqrt(
                    Math.pow(currentPath[i].x - currentPath[i-1].x, 2) +
                    Math.pow(currentPath[i].y - currentPath[i-1].y, 2)
                );
            }

            if (totalLength < 20) {
                console.log('‚ö†Ô∏è Trazo muy corto (<20px), no guardado');
                deactivateDrawingMode();
                return;
            }

            // Crear path con flecha
            const color = getPathColor(selectedForDrawing);
            const pathGroup = createPathWithArrow(currentPath, color);

            if (pathGroup) {
                canvas.add(pathGroup);

                // Enviar atr√°s de los jugadores pero adelante de la cancha
                pathGroup.sendToBack();
                // Traer la cancha al fondo
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'image') {
                        obj.sendToBack();
                    }
                });

                // Guardar movimiento
                saveMovement(selectedForDrawing, currentPath, pathGroup);

                canvas.renderAll();
            }

            // Desactivar modo dibujo
            deactivateDrawingMode();
        });

        // Preview temporal mientras dibuja
        let previewLine = null;

        function drawPreviewLine() {
            clearPreviewLine();

            if (currentPath.length < 2) return;

            let pathString = `M ${currentPath[0].x} ${currentPath[0].y}`;
            for (let i = 1; i < currentPath.length; i++) {
                pathString += ` L ${currentPath[i].x} ${currentPath[i].y}`;
            }

            const color = getPathColor(selectedForDrawing);

            previewLine = new fabric.Path(pathString, {
                fill: null,
                stroke: color,
                strokeWidth: 3,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                opacity: 0.6
            });

            canvas.add(previewLine);
            canvas.renderAll();
        }

        function clearPreviewLine() {
            if (previewLine) {
                canvas.remove(previewLine);
                previewLine = null;
            }
        }

        // ============================================
        // 2.7 SISTEMA DE ANIMACI√ìN
        // ============================================

        // Guardar posiciones originales de todos los objetos
        function saveOriginalPositions() {
            originalPositions = {};

            // Guardar posiciones de jugadores
            players.forEach(p => {
                originalPositions[p.playerNumber] = {
                    left: p.left,
                    top: p.top
                };
            });

            // Guardar posici√≥n del bal√≥n
            if (rugbyBall) {
                originalPositions['ball'] = {
                    left: rugbyBall.left,
                    top: rugbyBall.top
                };
            }

            console.log('üíæ Posiciones originales guardadas:', Object.keys(originalPositions).length, 'objetos');
        }

        // Encontrar objeto por ID
        function findObjectById(id) {
            if (id === 'ball') {
                return rugbyBall;
            }
            return players.find(p => p.playerNumber === id);
        }

        // Animar un objeto siguiendo un path de puntos
        // hasBall: si es true, tambi√©n mueve el bal√≥n junto con el jugador
        function animateObjectAlongPath(obj, points, duration, callback, hasBall = false) {
            if (!obj || points.length < 2) {
                if (callback) callback();
                return;
            }

            const totalPoints = points.length;
            const timePerSegment = duration / (totalPoints - 1);
            let currentPointIndex = 0;

            function animateToNextPoint() {
                if (currentPointIndex >= totalPoints - 1) {
                    // Animaci√≥n completada
                    if (callback) callback();
                    return;
                }

                const startPoint = points[currentPointIndex];
                const endPoint = points[currentPointIndex + 1];

                // Calcular distancia para ajustar velocidad
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) +
                    Math.pow(endPoint.y - startPoint.y, 2)
                );

                // Tiempo proporcional a la distancia (m√≠nimo 20ms)
                const segmentTime = Math.max(20, timePerSegment * (distance / 20));

                // Animar hacia el siguiente punto
                fabric.util.animate({
                    startValue: 0,
                    endValue: 1,
                    duration: segmentTime,
                    easing: fabric.util.ease.easeInOutQuad,
                    onChange: function(value) {
                        const newLeft = startPoint.x + (endPoint.x - startPoint.x) * value;
                        const newTop = startPoint.y + (endPoint.y - startPoint.y) * value;

                        // Mover jugador
                        obj.set({
                            left: newLeft,
                            top: newTop
                        });
                        obj.setCoords();

                        // Si tiene bal√≥n, moverlo tambi√©n
                        if (hasBall && rugbyBall) {
                            rugbyBall.set({
                                left: newLeft + BALL_OFFSET_X,
                                top: newTop + BALL_OFFSET_Y
                            });
                            rugbyBall.dirty = true;
                            rugbyBall.setCoords();
                        }

                        canvas.renderAll();
                    },
                    onComplete: function() {
                        currentPointIndex++;
                        animateToNextPoint();
                    }
                });
            }

            // Iniciar animaci√≥n
            animateToNextPoint();
        }

        // ============================================
        // SISTEMA DE FASES AUTOM√ÅTICO
        // ============================================

        // Agrupar movimientos y pases en fases
        function groupIntoPhases(actions) {
            const phases = [];
            let currentGroup = [];

            actions.forEach(action => {
                if (action.type === 'movement') {
                    // Agregar a grupo actual de movimientos
                    currentGroup.push(action);
                } else if (action.type === 'pass') {
                    // Cerrar grupo actual (movimientos simult√°neos)
                    if (currentGroup.length > 0) {
                        phases.push({
                            type: 'simultaneous',
                            actions: currentGroup
                        });
                        currentGroup = [];
                    }

                    // Agregar pase como fase secuencial
                    phases.push({
                        type: 'pass',
                        actions: [action]
                    });
                }
            });

            // Cerrar √∫ltimo grupo si existe
            if (currentGroup.length > 0) {
                phases.push({
                    type: 'simultaneous',
                    actions: currentGroup
                });
            }

            return phases;
        }

        // Reproducir todos los movimientos (controlador principal con fases)
        function playAllMovements() {
            if (isPlaying || movements.length === 0) {
                return;
            }

            // Guardar posiciones originales antes de animar
            saveOriginalPositions();

            isPlaying = true;
            currentAnimationIndex = 0;

            // Actualizar UI
            $('#btnPlay').prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> Reproduciendo...');
            $('#btnReset').prop('disabled', true);
            $('#btnDrawMovement').prop('disabled', true);
            $('#btnCreatePass').prop('disabled', true);

            // Agrupar en fases
            const phases = groupIntoPhases(movements);
            let currentPhaseIndex = 0;

            console.log('‚ñ∂Ô∏è Iniciando reproducci√≥n:', phases.length, 'fases');

            function playNextPhase() {
                if (currentPhaseIndex >= phases.length) {
                    finishPlayback();
                    return;
                }

                const phase = phases[currentPhaseIndex];
                const phaseNum = currentPhaseIndex + 1;
                const totalPhases = phases.length;

                if (phase.type === 'simultaneous') {
                    // Movimientos simult√°neos
                    const count = phase.actions.length;
                    $('#animationStatus').html(
                        `<i class="fas fa-bolt text-warning"></i> Fase ${phaseNum}/${totalPhases} (${count} movimientos simult√°neos)...`
                    );
                    console.log(`  üìç Fase ${phaseNum}: ${count} movimientos simult√°neos`);

                    playSimultaneousPhase(phase.actions, () => {
                        currentPhaseIndex++;
                        setTimeout(playNextPhase, 300);
                    });
                } else if (phase.type === 'pass') {
                    // Pase individual
                    const passAction = phase.actions[0];
                    $('#animationStatus').html(
                        `<i class="fas fa-football-ball text-primary"></i> Fase ${phaseNum}/${totalPhases} (Pase ${passAction.from}‚Üí${passAction.to})...`
                    );
                    console.log(`  üèà Fase ${phaseNum}: Pase ${passAction.from} ‚Üí ${passAction.to}`);

                    animatePass(passAction, () => {
                        currentPhaseIndex++;
                        setTimeout(playNextPhase, 300);
                    });
                }
            }

            // Iniciar
            playNextPhase();
        }

        // Reproducir fase de movimientos simult√°neos
        function playSimultaneousPhase(actions, callback) {
            const animationPromises = [];
            const duration = 2000;

            actions.forEach(movement => {
                if (movement.type !== 'movement') return;

                const obj = findObjectById(movement.playerId);
                if (!obj) {
                    console.warn('‚ö†Ô∏è Objeto no encontrado:', movement.playerId);
                    return;
                }

                const promise = new Promise((resolve) => {
                    const hasBall = movement.hasBall || false;
                    animateObjectAlongPath(obj, movement.points, duration, () => {
                        console.log(`    ‚úì ${movement.playerId} completado`);
                        resolve();
                    }, hasBall);
                });

                animationPromises.push(promise);
            });

            if (animationPromises.length === 0) {
                callback();
                return;
            }

            Promise.all(animationPromises).then(() => {
                callback();
            });
        }

        // Animar un pase (bal√≥n viaja de jugador a jugador)
        function animatePass(passAction, callback) {
            const fromPlayer = findObjectById(passAction.from);
            const toPlayer = findObjectById(passAction.to);

            if (!rugbyBall || !fromPlayer || !toPlayer) {
                console.error('‚ùå Error: Objetos no encontrados para el pase');
                callback();
                return;
            }

            // Calcular posici√≥n destino del bal√≥n
            const toCenter = toPlayer.getCenterPoint();
            const targetX = toCenter.x + BALL_OFFSET_X;
            const targetY = toCenter.y + BALL_OFFSET_Y;

            console.log(`    üèà Bal√≥n: (${rugbyBall.left.toFixed(0)},${rugbyBall.top.toFixed(0)}) ‚Üí (${targetX.toFixed(0)},${targetY.toFixed(0)})`);

            // Animar bal√≥n en l√≠nea recta
            fabric.util.animate({
                startValue: 0,
                endValue: 1,
                duration: 500,  // 0.5 segundos
                easing: fabric.util.ease.easeInOutQuad,
                onChange: function(value) {
                    const startX = rugbyBall.left;
                    const startY = rugbyBall.top;

                    // Solo en la primera iteraci√≥n guardamos el inicio
                    if (value === 0 || !rugbyBall._passStartX) {
                        rugbyBall._passStartX = rugbyBall.left;
                        rugbyBall._passStartY = rugbyBall.top;
                    }

                    const newX = rugbyBall._passStartX + (targetX - rugbyBall._passStartX) * value;
                    const newY = rugbyBall._passStartY + (targetY - rugbyBall._passStartY) * value;

                    rugbyBall.set({ left: newX, top: newY });
                    rugbyBall.dirty = true;
                    rugbyBall.setCoords();
                    canvas.renderAll();
                },
                onComplete: function() {
                    // Limpiar variables temporales
                    delete rugbyBall._passStartX;
                    delete rugbyBall._passStartY;

                    // Posici√≥n final exacta
                    rugbyBall.set({ left: targetX, top: targetY });
                    rugbyBall.setCoords();
                    canvas.renderAll();

                    console.log('    ‚úì Pase completado');
                    callback();
                }
            });
        }

        // Finalizar reproducci√≥n
        function finishPlayback() {
            isPlaying = false;
            currentAnimationIndex = 0;

            // Restaurar UI
            $('#btnPlay').prop('disabled', false).html('<i class="fas fa-play"></i> Play');
            $('#btnReset').prop('disabled', false);
            updatePlayButton();
            updatePassButton();

            $('#animationStatus').html('<i class="fas fa-check-circle text-success"></i> Reproducci√≥n completa');

            console.log('‚úÖ Reproducci√≥n completada');

            // Restaurar mensaje despu√©s de 2 segundos
            setTimeout(() => {
                if (!isPlaying) {
                    $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
                }
            }, 2000);
        }

        // Resetear a posiciones originales
        function resetToOriginalPositions() {
            if (isPlaying) {
                alert('‚ö†Ô∏è Espera a que termine la reproducci√≥n');
                return;
            }

            // Si no hay posiciones guardadas, guardar las actuales como referencia
            if (Object.keys(originalPositions).length === 0) {
                if (players.length === 0) {
                    alert('‚ö†Ô∏è No hay jugadores en el canvas');
                    return;
                }
                saveOriginalPositions();
                console.log('üíæ Posiciones actuales guardadas como referencia');
                $('#animationStatus').html('<i class="fas fa-save text-info"></i> Posiciones guardadas como referencia');
                setTimeout(() => {
                    $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
                }, 1500);
                return;
            }

            console.log('‚ü≤ Restaurando posiciones originales...');
            let restoredCount = 0;

            // Restaurar posiciones de jugadores
            players.forEach(p => {
                const origPos = originalPositions[p.playerNumber];
                if (origPos) {
                    console.log(`  ‚îî‚îÄ Jugador ${p.playerNumber}: (${p.left.toFixed(0)},${p.top.toFixed(0)}) ‚Üí (${origPos.left.toFixed(0)},${origPos.top.toFixed(0)})`);
                    p.set({
                        left: origPos.left,
                        top: origPos.top
                    });
                    p.dirty = true;
                    p.setCoords();
                    restoredCount++;
                }
            });

            // Restaurar posici√≥n del bal√≥n
            if (rugbyBall && originalPositions['ball']) {
                const ballOrig = originalPositions['ball'];
                console.log(`  ‚îî‚îÄ Bal√≥n: (${rugbyBall.left.toFixed(0)},${rugbyBall.top.toFixed(0)}) ‚Üí (${ballOrig.left.toFixed(0)},${ballOrig.top.toFixed(0)})`);
                rugbyBall.set({
                    left: ballOrig.left,
                    top: ballOrig.top
                });
                rugbyBall.dirty = true;
                rugbyBall.setCoords();
                restoredCount++;
            }

            // Forzar re-renderizado completo
            canvas.requestRenderAll();
            canvas.renderAll();

            console.log(`‚úÖ ${restoredCount} objetos restaurados`);

            $('#animationStatus').html(`<i class="fas fa-undo text-success"></i> ${restoredCount} posiciones restauradas`);
            setTimeout(() => {
                $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
            }, 1500);
        }

        // Actualizar estado del bot√≥n Play
        function updatePlayButton() {
            const hasMovements = movements.length > 0;
            $('#btnPlay').prop('disabled', !hasMovements || isPlaying);
        }

        // ============================================
        // 2.8 SISTEMA DE POSESI√ìN DEL BAL√ìN
        // ============================================

        // Actualizar UI de posesi√≥n
        function updatePossessionUI() {
            // Habilitar bot√≥n asignar si hay bal√≥n
            $('#btnAssignPossession').prop('disabled', !rugbyBall);

            // Mostrar/ocultar bot√≥n soltar
            if (ballPossession !== null) {
                $('#btnReleasePossession').show();
                $('#btnAssignPossession').hide();
            } else {
                $('#btnReleasePossession').hide();
                if (rugbyBall) {
                    $('#btnAssignPossession').show();
                }
            }
        }

        // Activar modo asignaci√≥n de posesi√≥n
        function activateAssignPossessionMode() {
            if (!rugbyBall) {
                alert('‚ö†Ô∏è Primero agrega un bal√≥n al canvas');
                return;
            }

            isAssigningPossession = true;
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';

            $('#btnAssignPossession')
                .removeClass('btn-outline-warning')
                .addClass('btn-warning')
                .html('<i class="fas fa-times"></i> Cancelar');

            console.log('üèà Modo asignaci√≥n: Click en un jugador para darle el bal√≥n');
        }

        // Desactivar modo asignaci√≥n
        function deactivateAssignPossessionMode() {
            isAssigningPossession = false;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';

            $('#btnAssignPossession')
                .removeClass('btn-warning')
                .addClass('btn-outline-warning')
                .html('<i class="fas fa-hand-holding"></i> Asignar posesi√≥n');
        }

        // Asignar posesi√≥n a un jugador
        function assignPossessionTo(player) {
            if (!rugbyBall || !player || !player.isPlayer) {
                console.log('‚ö†Ô∏è No se puede asignar: rugbyBall=', !!rugbyBall, 'player=', !!player);
                return;
            }

            console.log('üèà Iniciando asignaci√≥n de bal√≥n a jugador', player.playerNumber);

            // Si ya ten√≠a posesi√≥n otro jugador, quitar su listener
            if (ballPossession !== null) {
                const prevPlayer = players.find(p => p.playerNumber === ballPossession);
                if (prevPlayer) {
                    prevPlayer.off('moving');  // Quitar listener anterior
                    prevPlayer.hasBallPossession = false;
                    console.log('  ‚îî‚îÄ Removido listener del jugador anterior:', ballPossession);
                }
            }

            // Asignar nuevo poseedor
            ballPossession = player.playerNumber;
            player.hasBallPossession = true;

            // Obtener posici√≥n real del centro del jugador
            const playerCenter = player.getCenterPoint();
            console.log('  ‚îî‚îÄ Centro del jugador:', playerCenter.x.toFixed(0), playerCenter.y.toFixed(0));

            // Guardar posici√≥n anterior del bal√≥n para debug
            const oldPos = { left: rugbyBall.left, top: rugbyBall.top };

            // MOVER BAL√ìN F√çSICAMENTE cerca del jugador
            const newLeft = playerCenter.x + BALL_OFFSET_X;
            const newTop = playerCenter.y + BALL_OFFSET_Y;

            rugbyBall.set({
                left: newLeft,
                top: newTop
            });

            // Forzar que Fabric.js reconozca el cambio
            rugbyBall.dirty = true;
            rugbyBall.setCoords();

            // Traer bal√≥n al frente para asegurar visibilidad
            canvas.bringToFront(rugbyBall);

            console.log('  ‚îî‚îÄ Bal√≥n movido de (' + oldPos.left.toFixed(0) + ',' + oldPos.top.toFixed(0) +
                ') a (' + newLeft.toFixed(0) + ',' + newTop.toFixed(0) + ')');

            // Agregar listener para cuando el jugador se mueva
            player.on('moving', function() {
                if (ballPossession === this.playerNumber && rugbyBall) {
                    const center = this.getCenterPoint();
                    rugbyBall.set({
                        left: center.x + BALL_OFFSET_X,
                        top: center.y + BALL_OFFSET_Y
                    });
                    rugbyBall.dirty = true;
                    rugbyBall.setCoords();
                }
            });

            // Forzar renderizado S√çNCRONO
            canvas.renderAll();

            updatePossessionUI();

            console.log('‚úÖ Posesi√≥n asignada a jugador', ballPossession);
        }

        // Remover listener de movimiento (sin indicador visual)
        function removePossessionListener(playerId) {
            const player = players.find(p => p.playerNumber === playerId);
            if (player) {
                player.off('moving');
                player.hasBallPossession = false;
            }
        }

        // Soltar bal√≥n (liberar posesi√≥n)
        function releasePossession() {
            if (ballPossession === null) {
                return;
            }

            // Quitar listener de movimiento
            removePossessionListener(ballPossession);

            // Liberar posesi√≥n
            const previousOwner = ballPossession;
            ballPossession = null;

            updatePossessionUI();
            canvas.renderAll();

            console.log('üèà Bal√≥n soltado por jugador', previousOwner);
        }

        // Limpiar posesi√≥n (para usar en clearAllPlayers)
        function clearPossession() {
            if (ballPossession !== null) {
                removePossessionListener(ballPossession);
                ballPossession = null;
            }
            updatePossessionUI();
        }

        // ============================================
        // 2.9 SISTEMA DE PASES
        // ============================================

        // Actualizar estado del bot√≥n Crear Pase
        function updatePassButton() {
            // Habilitar solo si hay bal√≥n asignado a un jugador
            const canCreatePass = ballPossession !== null && rugbyBall !== null;
            $('#btnCreatePass').prop('disabled', !canCreatePass);
        }

        // Activar modo crear pase
        function activateCreatePassMode() {
            if (ballPossession === null) {
                alert('‚ö†Ô∏è Primero asigna el bal√≥n a un jugador');
                return;
            }

            isCreatingPass = true;
            passFromPlayer = null;
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';

            // Cambiar estilo del bot√≥n
            $('#btnCreatePass')
                .removeClass('btn-primary')
                .addClass('btn-warning')
                .html('‚ùå Cancelar Pase');

            // Deshabilitar otros botones
            $('#btnDrawMovement').prop('disabled', true);
            $('#btnAssignPossession').prop('disabled', true);

            console.log('üîó Modo pase activado. Click en jugador con bal√≥n, luego en destino.');
            $('#animationStatus').html('<i class="fas fa-hand-point-up text-primary"></i> Click en jugador con bal√≥n...');
        }

        // Desactivar modo crear pase
        function deactivateCreatePassMode() {
            isCreatingPass = false;
            passFromPlayer = null;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';

            // Restaurar estilo del bot√≥n
            $('#btnCreatePass')
                .removeClass('btn-warning')
                .addClass('btn-primary')
                .html('üîó Crear Pase');

            // Rehabilitar botones
            const hasSelection = canvas.getActiveObject();
            $('#btnDrawMovement').prop('disabled', !hasSelection);
            updatePossessionUI();

            $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
        }

        // Crear pase entre dos jugadores
        function createPass(fromPlayer, toPlayer) {
            if (!fromPlayer || !toPlayer) {
                console.error('‚ùå Error: Jugadores no v√°lidos para el pase');
                return;
            }

            console.log(`üîó Creando pase: ${fromPlayer.playerNumber} ‚Üí ${toPlayer.playerNumber}`);

            // Obtener centros de los jugadores
            const fromCenter = fromPlayer.getCenterPoint();
            const toCenter = toPlayer.getCenterPoint();

            // 1. Crear l√≠nea punteada azul
            const passLine = new fabric.Line([
                fromCenter.x, fromCenter.y,
                toCenter.x, toCenter.y
            ], {
                stroke: '#0066CC',
                strokeWidth: 3,
                strokeDashArray: [8, 4],
                selectable: false,
                evented: false,
                isPassPath: true,
                fromId: fromPlayer.playerNumber,
                toId: toPlayer.playerNumber
            });

            // 2. Calcular √°ngulo para la flecha
            const angle = Math.atan2(
                toCenter.y - fromCenter.y,
                toCenter.x - fromCenter.x
            ) * 180 / Math.PI;

            // 3. Crear punta de flecha
            const arrowHead = new fabric.Triangle({
                left: toCenter.x,
                top: toCenter.y,
                fill: '#0066CC',
                width: 15,
                height: 18,
                angle: angle + 90,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                isPassArrow: true
            });

            // 4. Agregar al canvas
            canvas.add(passLine);
            canvas.add(arrowHead);

            // Enviar detr√°s de jugadores
            passLine.sendToBack();
            arrowHead.sendToBack();
            // Mantener cancha al fondo
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'image') obj.sendToBack();
            });

            // 5. Guardar en movements[] como tipo 'pass'
            movements.push({
                type: 'pass',
                from: fromPlayer.playerNumber,
                to: toPlayer.playerNumber,
                passPath: passLine,
                passArrow: arrowHead
            });

            // 6. Transferir posesi√≥n al receptor
            releasePossession();
            assignPossessionTo(toPlayer);

            console.log(`‚úÖ Pase creado: ${fromPlayer.playerNumber} ‚Üí ${toPlayer.playerNumber}`);

            // Actualizar botones
            updatePlayButton();
            updatePassButton();

            canvas.renderAll();
        }

        // ============================================
        // 3. ELIMINAR JUGADOR SELECCIONADO
        // ============================================
        function deleteSelectedPlayer() {
            const activeObject = canvas.getActiveObject();

            if (activeObject && activeObject.isPlayer) {
                canvas.remove(activeObject);
                players = players.filter(p => p !== activeObject);
                selectedPlayer = null;
                canvas.renderAll();
            } else if (activeObject && activeObject.isBall) {
                // Eliminar bal√≥n si est√° seleccionado
                eliminarBalon();
            } else {
                alert('‚ö†Ô∏è Selecciona un jugador o bal√≥n primero (click sobre √©l)');
            }
        }

        // ============================================
        // 4. LIMPIAR JUGADORES
        // ============================================
        function clearAllPlayers() {
            players.forEach(player => canvas.remove(player));
            players = [];
            playerCounter = 1;
            selectedPlayer = null;
            // Tambi√©n eliminar el bal√≥n
            eliminarBalon();
            // Tambi√©n limpiar movimientos/trayectorias
            clearAllMovements();
            canvas.renderAll();
        }

        // ============================================
        // 5. FORMACIONES PREDEFINIDAS
        // ============================================
        function applyFormacion() {
            const formacion = $('#formacionSelect').val();

            if (!formacion) {
                alert('‚ö†Ô∏è Selecciona una formaci√≥n primero');
                return;
            }

            clearAllPlayers();

            switch(formacion) {
                case 'scrum':
                    formacionScrum();
                    break;
                case 'lineout':
                    formacionLineout();
                    break;
                case 'lineout_completo':
                    formacionLineoutCompleto();
                    break;
                case 'ruck':
                    formacionRuck();
                    break;
                case 'maul':
                    formacionMaul();
                    break;
                case 'backs':
                    formacionBacks();
                    break;
                case 'kickoff':
                    formacionKickoff();
                    break;
                case 'full15':
                    formacionFull15();
                    break;
            }

            // Guardar posiciones originales despu√©s de aplicar formaci√≥n
            setTimeout(() => {
                saveOriginalPositions();
            }, 100);
        }

        // ============== FORMACIONES FORWARDS ==============

        // Scrum 3-4-1 (atacando de izquierda ‚Üí derecha)
        function formacionScrum() {
            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  SCRUM 3-4-1 - Atacando IZQUIERDA ‚Üí DERECHA              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                            ‚ïë
‚ïë  ATR√ÅS (izquierda)              ADELANTE (derecha)        ‚ïë
‚ïë                                                            ‚ïë
‚ïë                        6                1                  ‚ïë
‚ïë                        4                2                  ‚ïë
‚ïë    9 ‚îÄ‚îÄ 8                                                  ‚ïë
‚ïë                        5                3                  ‚ïë
‚ïë                        7                                   ‚ïë
‚ïë                                                            ‚ïë
‚ïë  Direcci√≥n de ataque:  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫              ‚ïë
‚ïë                                                            ‚ïë
‚ïë  1,2,3 = Primera l√≠nea (m√°s adelante)                     ‚ïë
‚ïë  4,5 = Segunda l√≠nea                                       ‚ïë
‚ïë  6 = Flanker (arriba del 4, misma columna)                ‚ïë
‚ïë  7 = Flanker (abajo del 5, misma columna)                 ‚ïë
‚ïë  8 = Octavo (cerca del 9)                                  ‚ïë
‚ïë  9 = Medio scrum                                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            `);

            const baseX = 350;
            const baseY = 325;

            // Medio scrum (alejado) y Octavo (pegado al scrum)
            addPlayer('back', baseX - 50, baseY, 9);
            addPlayer('forward', baseX + 70, baseY, 8);

            // SEGUNDA l√≠nea (segundas l√≠neas)
            addPlayer('forward', baseX + 110, baseY - 20, 4);
            addPlayer('forward', baseX + 110, baseY + 20, 5);

            // TERCERA l√≠nea (flankers) - misma columna X que 4 y 5
            addPlayer('forward', baseX + 110, baseY - 55, 6);  // Flanker arriba del 4
            addPlayer('forward', baseX + 110, baseY + 55, 7);  // Flanker abajo del 5

            // PRIMERA l√≠nea (pegada a la segunda)
            addPlayer('forward', baseX + 150, baseY - 35, 1);  // Pilar arriba
            addPlayer('forward', baseX + 150, baseY, 2);       // Hooker centro
            addPlayer('forward', baseX + 150, baseY + 35, 3);  // Pilar abajo

            playerCounter = 10;
        }

        // Lineout 5 jugadores (simplificado)
        function formacionLineout() {
            const baseX = 500;
            const startY = 180;
            const spacing = 75;

            // L√≠nea vertical de forwards en el lateral (5 saltadores)
            addPlayer('forward', baseX, startY, 4);           // 1er saltador
            addPlayer('forward', baseX, startY + spacing, 5); // 2do saltador
            addPlayer('forward', baseX, startY + spacing * 2, 6); // 3er saltador
            addPlayer('forward', baseX, startY + spacing * 3, 7); // 4to saltador
            addPlayer('forward', baseX, startY + spacing * 4, 2); // Hooker

            // Medio scrum ATR√ÅS esperando el bal√≥n (m√°s a la izquierda)
            addPlayer('back', baseX - 100, startY + spacing * 2, 9);

            playerCounter = 10;
        }

        // Lineout completo (8 forwards)
        function formacionLineoutCompleto() {
            const baseX = 550;
            const startY = 130;
            const spacing = 60;

            // L√≠nea de lineout (8 forwards) en el lateral
            addPlayer('forward', baseX, startY, 1);
            addPlayer('forward', baseX, startY + spacing, 4);
            addPlayer('forward', baseX, startY + spacing * 2, 5);
            addPlayer('forward', baseX, startY + spacing * 3, 6);
            addPlayer('forward', baseX, startY + spacing * 4, 7);
            addPlayer('forward', baseX, startY + spacing * 5, 8);
            addPlayer('forward', baseX, startY + spacing * 6, 3);
            addPlayer('forward', baseX, startY + spacing * 7, 2); // Hooker

            // Medio scrum ATR√ÅS (m√°s a la izquierda)
            addPlayer('back', baseX - 100, startY + spacing * 3.5, 9);

            playerCounter = 10;
        }

        // Ruck - Agrupamiento tras tackle (basado en imagen proporcionada)
        function formacionRuck() {
            // === FULLBACK - MUY ATR√ÅS (alineado con 10) ===
            addPlayer('back', 350, 305, 15);

            // === WINGS Y BACKS PROFUNDOS ===
            addPlayer('back', 470, 50, 11);       // Wing arriba
            addPlayer('back', 530, 130, 13);      // Centro ext
            addPlayer('back', 560, 560, 14);      // Wing abajo

            // === BACKS SOPORTE MEDIO ===
            addPlayer('back', 590, 220, 12);      // Centro int
            addPlayer('back', 650, 305, 10);      // Apertura

            // === FORWARDS ATR√ÅS DEL RUCK ===
            addPlayer('forward', 680, 450, 1);    // Prop
            addPlayer('forward', 680, 500, 2);    // Hooker

            // === EL RUCK (agrupamiento central) ===
            addPlayer('forward', 740, 220, 4);    // Lock - adelante
            addPlayer('forward', 710, 270, 3);    // Prop - atr√°s
            addPlayer('forward', 710, 195, 5);    // Lock - atr√°s

            // === FORWARDS ADELANTE (derecha del ruck) ===
            addPlayer('back', 830, 390, 9);       // Medio scrum
            addPlayer('forward', 880, 385, 8);    // N√∫mero 8
            addPlayer('forward', 920, 360, 7);    // Flanker
            addPlayer('forward', 920, 430, 6);    // Flanker - alineado con 7

            playerCounter = 16;
        }

        // Maul - Forwards agrupados pero separados, backs espaciados
        function formacionMaul() {
            // === BACKS ESPACIADOS (igual que formaci√≥n 15 jugadores) ===
            addPlayer('back', 370, 340, 15);     // Fullback izquierda
            addPlayer('back', 490, 70, 11);      // Wing arriba
            addPlayer('back', 550, 150, 13);     // Centro ext
            addPlayer('back', 580, 235, 12);     // Centro int
            addPlayer('back', 640, 300, 10);     // Apertura
            addPlayer('back', 580, 550, 14);     // Wing abajo

            // === EL MAUL - FORWARDS AGRUPADOS PERO M√ÅS SEPARADOS ===
            addPlayer('back', 710, 400, 9);      // Medio scrum (borde izq maul)
            addPlayer('forward', 750, 395, 8);   // N√∫mero 8 (centro-izq)
            addPlayer('forward', 770, 360, 1);   // Prop (arriba-centro)
            addPlayer('forward', 780, 410, 2);   // Hooker (centro)
            addPlayer('forward', 770, 460, 6);   // Flanker (abajo-centro)
            addPlayer('forward', 810, 340, 4);   // Lock (arriba-der)
            addPlayer('forward', 820, 390, 5);   // Lock (centro-der)
            addPlayer('forward', 830, 440, 7);   // Flanker (abajo-der)
            addPlayer('forward', 850, 415, 3);   // Prop (extremo der)

            playerCounter = 16;
        }

        // ============== SITUACIONES ESPECIALES ==============

        // Kick-off - Formaci√≥n de recepci√≥n (basada en imagen de referencia)
        function formacionKickoff() {
            // === JUGADORES SUPERIORES (arriba de la cancha) ===
            addPlayer('back', 380, 80, 11);      // Wing izquierdo arriba
            addPlayer('back', 750, 140, 14);     // Wing derecho arriba

            // === SEGUNDA L√çNEA ===
            addPlayer('back', 380, 190, 13);     // Centro exterior
            addPlayer('back', 750, 230, 12);     // Centro interior

            // === TERCERA L√çNEA / ZONA CENTRAL ===
            addPlayer('back', 180, 280, 15);     // Fullback izquierda profundo
            addPlayer('back', 550, 280, 10);     // Apertura

            // === AGRUPAMIENTO CENTRAL (FORWARDS) ===
            addPlayer('forward', 650, 380, 1);   // Prop
            addPlayer('forward', 680, 410, 2);   // Hooker
            addPlayer('forward', 710, 380, 3);   // Prop
            addPlayer('forward', 780, 400, 4);   // Lock
            addPlayer('forward', 820, 370, 5);   // Lock

            // === ZONA INFERIOR DISPERSA ===
            addPlayer('back', 380, 420, 9);      // Medio scrum
            addPlayer('forward', 620, 480, 6);   // Flanker
            addPlayer('forward', 750, 480, 7);   // Flanker
            addPlayer('forward', 380, 540, 8);   // N√∫mero 8

            playerCounter = 16;
        }

        // ============== FORMACIONES BACKS ==============

        // Backs en l√≠nea de ataque (profundidad correcta, atacando izquierda ‚Üí derecha)
        function formacionBacks() {
            const baseX = 500;  // 9 m√°s adelante (cerca del scrum)
            const baseY = 325;

            // 9 m√°s ADELANTE (derecha) - recibe del 8
            addPlayer('back', baseX, baseY, 9);

            // 10 detr√°s del 9, un poco arriba
            addPlayer('back', baseX - 60, baseY - 50, 10);

            // 12 detr√°s del 10
            addPlayer('back', baseX - 120, baseY - 100, 12);

            // 13 detr√°s del 12
            addPlayer('back', baseX - 180, baseY - 150, 13);

            // 11 wing arriba (extremo, m√°s atr√°s)
            addPlayer('back', baseX - 240, baseY - 200, 11);

            // 15 fullback detr√°s del 9 como apoyo
            addPlayer('back', baseX - 60, baseY + 50, 15);

            // 14 wing abajo (extremo)
            addPlayer('back', baseX - 180, baseY + 150, 14);

            playerCounter = 16;
        }

        // ============== FORMACIONES COMPLETAS ==============

        // 15 jugadores completos (Scrum + Backs en l√≠nea de ataque)
        function formacionFull15() {
            const scrumX = 750;
            const scrumY = 420;  // Scrum un poco m√°s arriba
            const backsY = 320;  // Backs arriba

            // === FORWARDS ADELANTE (derecha) - Scrum m√°s abajo ===
            // Primera l√≠nea (m√°s adelante)
            addPlayer('forward', scrumX, scrumY - 35, 1);
            addPlayer('forward', scrumX, scrumY, 2);
            addPlayer('forward', scrumX, scrumY + 35, 3);

            // Segunda l√≠nea + Flankers (misma l√≠nea X, m√°s separados)
            addPlayer('forward', scrumX - 40, scrumY - 55, 6);
            addPlayer('forward', scrumX - 40, scrumY - 20, 4);
            addPlayer('forward', scrumX - 40, scrumY + 20, 5);
            addPlayer('forward', scrumX - 40, scrumY + 55, 7);

            // Octavo (m√°s cerca del scrum)
            addPlayer('forward', scrumX - 70, scrumY, 8);

            // === BACKS ATR√ÅS (izquierda) - Arriba en la cancha ===
            // 9 detr√°s del 8 (m√°s cerca)
            addPlayer('back', scrumX - 120, scrumY, 9);

            // 10 detr√°s del 9, arriba
            addPlayer('back', scrumX - 230, backsY, 10);

            // 12 detr√°s del 10 (menos profundo)
            addPlayer('back', scrumX - 280, backsY - 70, 12);

            // 13 detr√°s del 12 (menos profundo)
            addPlayer('back', scrumX - 330, backsY - 140, 13);

            // 11 wing arriba (extremo)
            addPlayer('back', scrumX - 380, backsY - 210, 11);

            // 15 fullback m√°s atr√°s que el 11
            addPlayer('back', scrumX - 430, backsY, 15);

            // 14 wing abajo
            addPlayer('back', scrumX - 330, scrumY + 100, 14);

            playerCounter = 16;
        }

        // ============================================
        // 6. GUARDAR JUGADA
        // ============================================
        function savePlay() {
            const playName = $('#playNameInput').val().trim();
            const playCategory = $('#playCategory').val();

            if (!playName) {
                alert('‚ö†Ô∏è Ingresa un nombre para la jugada');
                return;
            }

            if (players.length === 0) {
                alert('‚ö†Ô∏è Agrega al menos un jugador antes de guardar');
                return;
            }

            // Extraer datos simples de los jugadores
            const playersData = players.map(p => ({
                number: p.playerNumber,
                type: p.playerType,
                x: Math.round(p.left),
                y: Math.round(p.top)
            }));

            // Crear thumbnail
            const thumbnail = canvas.toDataURL({ format: 'png', quality: 0.6 });

            // Determinar icono de categor√≠a
            const categoryIcon = {
                'forwards': 'üü£',
                'backs': 'üü¢',
                'full_team': '‚ö™'
            }[playCategory] || '‚ö™';

            // Extraer datos del bal√≥n si existe
            const ballData = rugbyBall ? {
                x: Math.round(rugbyBall.left),
                y: Math.round(rugbyBall.top),
                isBall: true
            } : null;

            // Extraer datos de movimientos y pases (sin objetos Fabric no serializables)
            const movementsData = movements.map(action => {
                if (action.type === 'movement') {
                    return {
                        type: 'movement',
                        playerId: action.playerId,
                        playerType: action.playerType,
                        points: action.points,
                        hasBall: action.hasBall || false
                    };
                } else if (action.type === 'pass') {
                    return {
                        type: 'pass',
                        from: action.from,
                        to: action.to
                    };
                }
                return action;
            });

            // Crear objeto de jugada
            const play = {
                id: Date.now(),
                name: playName,
                category: playCategory,
                categoryIcon: categoryIcon,
                players: playersData,
                ball: ballData,  // Incluir bal√≥n
                ballPossession: ballPossession,  // Qui√©n tiene el bal√≥n
                movements: movementsData,  // Incluir movimientos
                thumbnail: thumbnail,
                created_at: new Date().toISOString()
            };

            // Guardar en localStorage
            let plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            plays.push(play);
            localStorage.setItem('rugbyPlays', JSON.stringify(plays));

            $('#playNameInput').val('');
            loadPlays();

            alert(`‚úÖ Jugada guardada: ${playName} (${categoryIcon} ${playCategory})`);
        }

        // ============================================
        // 7. CARGAR JUGADAS
        // ============================================
        function loadPlays() {
            const plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            const container = $('#savedPlaysList');

            if (plays.length === 0) {
                container.html('<p class="text-muted text-center small mb-0"><i class="fas fa-info-circle"></i> Sin jugadas</p>');
                $('#playCount').text('0');
                return;
            }

            $('#playCount').text(plays.length);

            let html = '';
            plays.reverse().forEach(play => {
                const date = new Date(play.created_at).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' });
                const categoryIcon = play.categoryIcon || '‚ö™';
                const categoryLabel = play.category ? play.category.replace('_', ' ') : 'general';

                html += `
                    <div class="saved-play-item">
                        <strong>${categoryIcon} ${play.name}</strong><br>
                        <small class="text-muted">
                            ${play.players.length} jug. ¬∑ ${date}
                        </small>
                        <div class="mt-1">
                            <button class="btn btn-sm btn-info load-play" data-id="${play.id}" title="Cargar">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="btn btn-sm btn-danger delete-play" data-id="${play.id}" title="Eliminar">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

            container.html(html);
        }

        // ============================================
        // 8. CARGAR JUGADA ESPEC√çFICA
        // ============================================
        $(document).on('click', '.load-play', function() {
            const playId = $(this).data('id');
            const plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            const play = plays.find(p => p.id === playId);

            if (!play) {
                alert('‚ùå Jugada no encontrada');
                return;
            }

            clearAllPlayers();

            // Recrear jugadores desde los datos guardados
            play.players.forEach(p => {
                addPlayer(p.type, p.x, p.y, p.number);
            });

            // Restaurar bal√≥n si exist√≠a
            if (play.ball && play.ball.isBall) {
                crearBalon(play.ball.x, play.ball.y);
            }

            // Restaurar movimientos y pases si exist√≠an
            if (play.movements && play.movements.length > 0) {
                play.movements.forEach(action => {
                    if (action.type === 'movement' || !action.type) {
                        // Es un movimiento (compatibilidad con datos antiguos sin type)
                        let color;
                        if (action.playerType === 'ball') {
                            color = '#FF8C00';
                        } else if (action.playerType === 'forward') {
                            color = '#1e4d2b';
                        } else {
                            color = '#28a745';
                        }

                        // Recrear path con flecha
                        const pathGroup = createPathWithArrow(action.points, color);
                        if (pathGroup) {
                            canvas.add(pathGroup);
                            pathGroup.sendToBack();

                            // Guardar en array de movimientos
                            movements.push({
                                type: 'movement',
                                playerId: action.playerId,
                                playerType: action.playerType,
                                points: action.points,
                                hasBall: action.hasBall || false,
                                pathObject: pathGroup
                            });
                        }
                    } else if (action.type === 'pass') {
                        // Es un pase - recrear visualmente
                        const fromPlayer = findObjectById(action.from);
                        const toPlayer = findObjectById(action.to);

                        if (fromPlayer && toPlayer) {
                            const fromCenter = fromPlayer.getCenterPoint();
                            const toCenter = toPlayer.getCenterPoint();

                            // Crear l√≠nea punteada azul
                            const passLine = new fabric.Line([
                                fromCenter.x, fromCenter.y,
                                toCenter.x, toCenter.y
                            ], {
                                stroke: '#0066CC',
                                strokeWidth: 3,
                                strokeDashArray: [8, 4],
                                selectable: false,
                                evented: false,
                                isPassPath: true
                            });

                            // Crear flecha
                            const angle = Math.atan2(
                                toCenter.y - fromCenter.y,
                                toCenter.x - fromCenter.x
                            ) * 180 / Math.PI;

                            const arrowHead = new fabric.Triangle({
                                left: toCenter.x,
                                top: toCenter.y,
                                fill: '#0066CC',
                                width: 15,
                                height: 18,
                                angle: angle + 90,
                                originX: 'center',
                                originY: 'center',
                                selectable: false,
                                evented: false,
                                isPassArrow: true
                            });

                            canvas.add(passLine);
                            canvas.add(arrowHead);
                            passLine.sendToBack();
                            arrowHead.sendToBack();

                            // Guardar en array
                            movements.push({
                                type: 'pass',
                                from: action.from,
                                to: action.to,
                                passPath: passLine,
                                passArrow: arrowHead
                            });
                        }
                    }
                });

                // Enviar cancha al fondo
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'image') {
                        obj.sendToBack();
                    }
                });

                canvas.renderAll();

                // Actualizar botones
                updatePlayButton();
                updatePassButton();
            }

            // Restaurar posesi√≥n del bal√≥n si exist√≠a
            if (play.ballPossession !== null && play.ballPossession !== undefined) {
                const playerWithBall = players.find(p => p.playerNumber === play.ballPossession);
                if (playerWithBall && rugbyBall) {
                    assignPossessionTo(playerWithBall);
                }
            }

            // Guardar posiciones originales al cargar
            saveOriginalPositions();

            // Actualizar UI de posesi√≥n
            updatePossessionUI();

            $('#playNameInput').val(play.name);

            alert('‚úÖ Jugada cargada: ' + play.name);
        });

        // ============================================
        // 9. ELIMINAR JUGADA
        // ============================================
        $(document).on('click', '.delete-play', function() {
            const playId = $(this).data('id');

            if (!confirm('¬øEliminar esta jugada?')) return;

            let plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            plays = plays.filter(p => p.id !== playId);
            localStorage.setItem('rugbyPlays', JSON.stringify(plays));

            loadPlays();
        });

        // ============================================
        // 10. LIMPIAR CANVAS COMPLETO
        // ============================================
        function clearCanvas() {
            if (players.length === 0) {
                alert('‚ö†Ô∏è El canvas ya est√° vac√≠o');
                return;
            }

            if (confirm('¬øLimpiar toda la cancha y jugadores?')) {
                clearAllPlayers();
            }
        }

        // ============================================
        // 11. EVENT LISTENERS
        // ============================================
        $('#btnAddForward').on('click', () => addPlayer('forward'));
        $('#btnAddBack').on('click', () => addPlayer('back'));
        $('#btnAddBall').on('click', () => crearBalon());
        $('#btnDeleteSelected').on('click', deleteSelectedPlayer);
        $('#btnApplyFormacion').on('click', applyFormacion);
        $('#btnSavePlay').on('click', savePlay);
        $('#btnClearCanvas').on('click', clearCanvas);

        // Botones de trayectorias
        $('#btnDrawMovement').on('click', function() {
            if (isDrawingMode) {
                deactivateDrawingMode();
            } else {
                activateDrawingMode();
            }
        });

        $('#btnClearMovements').on('click', function() {
            if (movements.length === 0) {
                alert('‚ö†Ô∏è No hay trayectorias para borrar');
                return;
            }
            if (confirm('¬øBorrar todas las trayectorias?')) {
                clearAllMovements();
                updatePlayButton();
            }
        });

        // Botones de animaci√≥n
        $('#btnPlay').on('click', function() {
            if (!isPlaying && movements.length > 0) {
                playAllMovements();
            }
        });

        $('#btnReset').on('click', function() {
            resetToOriginalPositions();
        });

        // Botones de posesi√≥n del bal√≥n
        $('#btnAssignPossession').on('click', function() {
            if (isAssigningPossession) {
                deactivateAssignPossessionMode();
            } else {
                activateAssignPossessionMode();
            }
        });

        $('#btnReleasePossession').on('click', function() {
            releasePossession();
        });

        // Bot√≥n crear pase
        $('#btnCreatePass').on('click', function() {
            if (isCreatingPass) {
                deactivateCreatePassMode();
            } else {
                activateCreatePassMode();
            }
        });

        // Handler para asignar posesi√≥n y crear pases al hacer click en jugador
        canvas.on('mouse:down', function(opt) {
            const target = opt.target;

            // Modo asignar posesi√≥n
            if (isAssigningPossession) {
                if (target && target.isPlayer) {
                    assignPossessionTo(target);
                    deactivateAssignPossessionMode();
                }
                return;
            }

            // Modo crear pase
            if (isCreatingPass) {
                if (target && target.isPlayer) {
                    if (!passFromPlayer) {
                        // Primer click: Seleccionar origen (debe tener el bal√≥n)
                        if (target.playerNumber === ballPossession) {
                            passFromPlayer = target;
                            console.log('üîó Origen seleccionado: Jugador', passFromPlayer.playerNumber);
                            $('#animationStatus').html(`<i class="fas fa-hand-point-right text-primary"></i> Origen: ${passFromPlayer.playerNumber}. Click en destino...`);
                        } else {
                            alert('‚ö†Ô∏è El jugador seleccionado no tiene el bal√≥n.\n\nSelecciona al jugador ' + ballPossession + ' que tiene el bal√≥n.');
                        }
                    } else {
                        // Segundo click: Seleccionar destino
                        if (target.playerNumber === passFromPlayer.playerNumber) {
                            alert('‚ö†Ô∏è No puedes pasar el bal√≥n a ti mismo');
                            return;
                        }

                        // Crear el pase
                        createPass(passFromPlayer, target);

                        // Desactivar modo
                        deactivateCreatePassMode();
                    }
                }
                return;
            }
        });

        // Habilitar/deshabilitar bot√≥n de dibujo seg√∫n selecci√≥n
        canvas.on('selection:created', function(e) {
            const obj = e.selected[0];
            if (obj && (obj.isPlayer || obj.isBall)) {
                $('#btnDrawMovement').prop('disabled', false);
            }
        });

        canvas.on('selection:updated', function(e) {
            const obj = e.selected[0];
            if (obj && (obj.isPlayer || obj.isBall)) {
                $('#btnDrawMovement').prop('disabled', false);
            }
        });

        // Deseleccionar al hacer click en el fondo
        canvas.on('selection:cleared', function() {
            selectedPlayer = null;
            if (!isDrawingMode) {
                $('#btnDrawMovement').prop('disabled', true);
            }
        });

        // ============================================
        // 12. INICIALIZACI√ìN
        // ============================================
        $(document).ready(function() {
            drawRugbyField();
            loadPlays();

            console.log('‚úÖ Editor de Jugadas Rugby - FASE 2 Inicializado');
            console.log('üèâ Funcionalidades: Posiciones fijas, formaciones, guardar/cargar');
            console.log('üèà Bal√≥n: Agregar, arrastrar, eliminar, posesi√≥n');
            console.log('‚úèÔ∏è Trayectorias: Dibujar movimientos para jugadores/bal√≥n');
            console.log('üîó Pases: Crear pases entre jugadores con flecha azul');
            console.log('‚ñ∂Ô∏è Animaci√≥n: Sistema de fases (movimientos simult√°neos + pases secuenciales)');
            console.log('üìê Orientaci√≥n: Izquierda ‚Üí Derecha');
        });
    </script>
</body>
</html>
