<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Jugadas Rugby - Los Troncos</title>

    <!-- Bootstrap 4 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

    <style>
        body {
            background: #f4f6f9;
            font-family: 'Source Sans Pro', sans-serif;
        }

        .navbar-rugby {
            background: linear-gradient(135deg, #1e4d2b 0%, #28a745 100%);
            color: white;
            padding: 1rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .navbar-rugby h3 {
            margin: 0;
            color: white;
            font-weight: 600;
        }

        .canvas-container {
            border: 3px solid #1e4d2b !important;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn-rugby {
            background: #1e4d2b;
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-rugby:hover {
            background: #28a745;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-rugby i {
            margin-right: 0.5rem;
        }

        .tools-panel {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }

        .tools-panel .btn {
            font-size: 0.85rem;
            padding: 0.4rem 0.6rem;
        }

        .tools-panel .form-control {
            font-size: 0.85rem;
        }

        .tools-panel optgroup {
            font-weight: 600;
            font-style: normal;
        }

        .tools-panel option {
            padding-left: 0.5rem;
        }

        .canvas-wrapper {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .section-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: #1e4d2b;
            margin-top: 0.75rem;
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            border-bottom: 2px solid #1e4d2b;
            padding-bottom: 0.2rem;
        }

        .section-header:first-child {
            margin-top: 0;
        }

        .section-header i {
            font-size: 0.7rem;
        }

        #playNameInput, #formacionSelect {
            border: 2px solid #dee2e6;
            border-radius: 6px;
            transition: border-color 0.3s;
        }

        #playNameInput:focus, #formacionSelect:focus {
            border-color: #1e4d2b;
            box-shadow: 0 0 0 0.2rem rgba(30, 77, 43, 0.15);
        }

        .saved-play-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.4rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .saved-play-item:hover {
            background: #e9ecef;
            border-color: #1e4d2b;
            transform: translateX(3px);
        }

        .saved-play-item strong {
            color: #1e4d2b;
            font-size: 0.85rem;
        }

        .saved-play-item small {
            font-size: 0.7rem;
        }

        .saved-play-item .btn-sm {
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
        }

        .badge-rugby {
            background: #1e4d2b;
        }

        .alert-info-rugby {
            background: #d4edda;
            border: 1px solid #1e4d2b;
            color: #155724;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <div class="navbar-rugby">
        <div class="container-fluid">
            <h3>
                <i class="fas fa-chalkboard-teacher"></i>
                Editor de Jugadas Rugby - Los Troncos (FASE 1: Posiciones Fijas)
            </h3>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container-fluid">
        <div class="row">
            <!-- Canvas Area -->
            <div class="col-md-10">
                <div class="canvas-wrapper">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">
                            <i class="fas fa-football-ball"></i> Cancha de Rugby
                            <small class="text-muted">(Ataque: Izquierda ‚Üí Derecha)</small>
                        </h4>
                        <button id="btnClearCanvas" class="btn btn-danger btn-sm">
                            <i class="fas fa-trash"></i> Limpiar Todo
                        </button>
                    </div>
                    <canvas id="playCanvas" width="1200" height="650"></canvas>
                </div>
            </div>

            <!-- Tools Panel -->
            <div class="col-md-2">
                <!-- Info Alert -->
                <div class="alert-info-rugby">
                    <i class="fas fa-info-circle"></i>
                    <strong>Fase 1:</strong> Posiciones fijas. Arrastra para mover.
                </div>

                <!-- Panel 1: Formaciones -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-users"></i> Formaciones
                    </div>
                    <select id="formacionSelect" class="form-control form-control-sm mb-2">
                        <option value="">-- Selecciona --</option>
                        <optgroup label="üü£ Forwards">
                            <option value="scrum">Scrum</option>
                            <option value="lineout">Lineout 5</option>
                            <option value="lineout_completo">Lineout completo</option>
                            <option value="ruck">Ruck</option>
                            <option value="maul">Maul</option>
                        </optgroup>
                        <optgroup label="üü¢ Backs">
                            <option value="backs">Backs l√≠nea ataque</option>
                        </optgroup>
                        <optgroup label="üü° Situaciones Especiales">
                            <option value="kickoff">Kick-off (recepci√≥n)</option>
                        </optgroup>
                        <optgroup label="‚ö™ Equipo Completo">
                            <option value="full15">15 jugadores</option>
                        </optgroup>
                    </select>
                    <button id="btnApplyFormacion" class="btn btn-rugby btn-block btn-sm">
                        <i class="fas fa-check-circle"></i> Aplicar
                    </button>
                </div>

                <!-- Panel 2: Agregar Jugadores -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-user-plus"></i> Jugadores
                    </div>
                    <button id="btnAddPlayer" class="btn btn-danger btn-block mb-2">
                        <i class="fas fa-user-plus"></i> Agregar Jugador
                    </button>
                    <button id="btnAddBall" class="btn btn-warning btn-block mb-2">
                        üèà Bal√≥n
                    </button>
                    <button id="btnAssignPossession" class="btn btn-outline-warning btn-block mb-2" disabled>
                        <i class="fas fa-hand-holding"></i> Asignar posesi√≥n
                    </button>
                    <button id="btnReleasePossession" class="btn btn-outline-secondary btn-block mb-2" style="display: none;">
                        <i class="fas fa-hand-paper"></i> Soltar bal√≥n
                    </button>
                    <button id="btnDeleteSelected" class="btn btn-danger btn-block">
                        <i class="fas fa-trash-alt"></i> Eliminar
                    </button>
                </div>

                <!-- Panel 3: Trayectorias -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-route"></i> Trayectorias
                    </div>
                    <button id="btnDrawMovement" class="btn btn-info btn-block mb-2" disabled
                            title="Dibuja la trayectoria del jugador. Puedes dibujar m√∫ltiples trayectorias para el mismo jugador (antes y despu√©s de pases).">
                        <i class="fas fa-pencil-alt"></i> Dibujar movimiento
                    </button>
                    <button id="btnCreatePass" class="btn btn-primary btn-block mb-2" disabled
                            title="Click aqu√≠ y luego en el jugador que recibir√° el pase">
                        üîó Crear Pase
                    </button>
                    <div class="btn-group btn-block mb-2" role="group">
                        <button id="btnPlay" class="btn btn-success" disabled>
                            <i class="fas fa-play"></i> Play
                        </button>
                        <button id="btnReset" class="btn btn-secondary">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                    <!-- Lista de movimientos -->
                    <div id="movementsList" class="movements-list mt-2 mb-2" style="max-height: 150px; overflow-y: auto; font-size: 12px;">
                        <small class="text-muted">Sin movimientos</small>
                    </div>
                    <button id="btnClearMovements" class="btn btn-outline-danger btn-block btn-sm">
                        <i class="fas fa-eraser"></i> Borrar todas
                    </button>
                    <small id="animationStatus" class="text-muted d-block mt-2">
                        <i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero
                    </small>
                </div>

                <!-- Panel 4: Guardar -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-save"></i> Guardar
                    </div>
                    <input type="text" id="playNameInput" class="form-control form-control-sm mb-2"
                           placeholder="Nombre...">
                    <select id="playCategory" class="form-control form-control-sm mb-2">
                        <option value="forwards">üü£ Forwards</option>
                        <option value="backs">üü¢ Backs</option>
                        <option value="full_team">‚ö™ Equipo completo</option>
                    </select>
                    <button id="btnSavePlay" class="btn btn-rugby btn-block btn-sm">
                        <i class="fas fa-save"></i> Guardar
                    </button>
                </div>

                <!-- Panel 5: Jugadas Guardadas -->
                <div class="tools-panel">
                    <div class="section-header">
                        <i class="fas fa-folder-open"></i> Guardadas
                        <span class="badge badge-rugby float-right" id="playCount">0</span>
                    </div>
                    <div id="savedPlaysList" style="max-height: 250px; overflow-y: auto;">
                        <p class="text-muted text-center small mb-0">
                            <i class="fas fa-info-circle"></i> Sin jugadas
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // ============================================
        // üèâ RUGBY PLAY EDITOR - FASE 1
        // Sistema simple de posiciones fijas
        // ============================================

        const canvas = new fabric.Canvas('playCanvas', {
            backgroundColor: '#2d5a2d',
            selection: true
        });

        let playerCounter = 1;
        let players = [];
        let selectedPlayer = null;
        let rugbyBall = null;  // Variable para el bal√≥n

        // Variables para sistema de trayectorias
        let movements = [];           // Array de todos los movimientos
        let isDrawingMode = false;    // Modo dibujo activo
        let currentPath = [];         // Puntos del trazo actual
        let selectedForDrawing = null; // Objeto seleccionado para dibujar

        // Variables para sistema de animaci√≥n
        let originalPositions = {};      // Posiciones iniciales {playerId: {left, top}}
        let isPlaying = false;           // Estado de reproducci√≥n
        let currentAnimationIndex = 0;   // √çndice del movimiento actual

        // Variables para sistema de posesi√≥n del bal√≥n
        let ballPossession = null;       // ID del jugador que tiene el bal√≥n (null = libre)
        let originalBallHolder = null;   // ID del jugador que recibi√≥ el bal√≥n ORIGINALMENTE (antes de pases)
        let isAssigningPossession = false; // Modo asignaci√≥n activo

        // Variables para sistema de pases
        let isCreatingPass = false;      // Modo crear pase activo
        // Origen siempre es ballPossession (autoselecci√≥n)

        // Contador para IDs √∫nicos de movimientos/pases
        let movementIdCounter = 0;

        // Offsets globales para posici√≥n del bal√≥n (relativo al jugador)
        const BALL_OFFSET_X = 30;
        const BALL_OFFSET_Y = 0;

        // ============================================
        // 1. CARGAR CANCHA DE RUGBY EN EL CANVAS
        // ============================================
        function drawRugbyField() {
            fabric.Image.fromURL('cancha_rugby.png', function(img) {
                // Configurar la imagen para que cubra todo el canvas
                img.set({
                    left: 0,
                    top: 0,
                    scaleX: canvas.width / img.width,
                    scaleY: canvas.height / img.height,
                    selectable: false,
                    evented: false,
                    hasControls: false,
                    hasBorders: false
                });

                // Agregar como primer objeto (estar√° en el fondo)
                canvas.add(img);
                img.sendToBack();

                canvas.renderAll();
                console.log('‚úÖ Cancha de rugby cargada en canvas');
            });
        }

        // ============================================
        // 2. AGREGAR JUGADORES
        // ============================================
        function addPlayer(type = 'player', x = null, y = null, num = null) {
            const color = '#DC3545'; // Rojo para mejor visibilidad en cancha verde
            const playerNum = num !== null ? num : playerCounter;

            // C√≠rculo del jugador con sombra
            const circle = new fabric.Circle({
                radius: 20,
                fill: color,
                stroke: 'white',
                strokeWidth: 3,
                originX: 'center',
                originY: 'center',
                shadow: new fabric.Shadow({
                    color: 'rgba(0, 0, 0, 0.8)',
                    blur: 10,
                    offsetX: 2,
                    offsetY: 2
                })
            });

            // N√∫mero del jugador
            const text = new fabric.Text(playerNum.toString(), {
                fontSize: 18,
                fill: 'white',
                fontWeight: 'bold',
                originX: 'center',
                originY: 'center'
            });

            // Grupo (c√≠rculo + texto)
            const player = new fabric.Group([circle, text], {
                left: x !== null ? x : 300 + Math.random() * 400,
                top: y !== null ? y : 200 + Math.random() * 200,
                hasControls: false,
                hasBorders: true,
                borderColor: '#ffeb3b',
                borderScaleFactor: 3,
                cornerColor: '#DC3545',
                transparentCorners: false,
                lockRotation: true,
                playerType: type,
                playerNumber: playerNum,
                isPlayer: true
            });

            // Event: Selecci√≥n
            player.on('selected', function() {
                selectedPlayer = player;
            });

            canvas.add(player);
            players.push(player);

            if (num === null) {
                playerCounter++;
            }

            canvas.renderAll();
            return player;
        }

        // ============================================
        // 2.5 AGREGAR BAL√ìN DE RUGBY
        // ============================================
        function crearBalon(x = 600, y = 325) {
            // Si ya existe un bal√≥n, no crear otro
            if (rugbyBall) {
                alert('‚ö†Ô∏è Ya existe un bal√≥n en la cancha');
                return null;
            }

            // Crear elipse (forma de bal√≥n de rugby inclinado)
            const ball = new fabric.Ellipse({
                rx: 15,  // radio horizontal
                ry: 10,  // radio vertical
                fill: '#FFD700',  // amarillo
                stroke: '#8B4513',  // marr√≥n
                strokeWidth: 2,
                left: x,
                top: y,
                angle: -30,  // inclinaci√≥n del bal√≥n
                originX: 'center',
                originY: 'center',
                hasControls: false,
                hasBorders: true,
                borderColor: '#FF0000',
                borderScaleFactor: 3,
                lockRotation: true,
                isBall: true,  // identificador
                shadow: new fabric.Shadow({
                    color: 'rgba(0, 0, 0, 0.5)',
                    blur: 8,
                    offsetX: 2,
                    offsetY: 2
                })
            });

            canvas.add(ball);
            rugbyBall = ball;
            canvas.renderAll();

            // Actualizar UI de posesi√≥n
            updatePossessionUI();

            console.log('üèà Bal√≥n agregado en:', x, y);
            return ball;
        }

        function eliminarBalon() {
            if (rugbyBall) {
                // Limpiar posesi√≥n primero
                clearPossession();

                canvas.remove(rugbyBall);
                rugbyBall = null;
                canvas.renderAll();

                // Actualizar UI
                updatePossessionUI();

                console.log('üèà Bal√≥n eliminado');
            }
        }

        // ============================================
        // 2.6 SISTEMA DE TRAYECTORIAS/MOVIMIENTOS
        // ============================================

        // Activar modo dibujo
        function activateDrawingMode() {
            const activeObject = canvas.getActiveObject();

            if (!activeObject || (!activeObject.isPlayer && !activeObject.isBall)) {
                alert('‚ö†Ô∏è Selecciona un jugador o bal√≥n primero');
                return;
            }

            selectedForDrawing = activeObject;
            isDrawingMode = true;
            currentPath = [];

            // Cambiar cursor y estilo del canvas
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';
            canvas.selection = false;

            // Cambiar estilo del bot√≥n
            $('#btnDrawMovement').removeClass('btn-info').addClass('btn-warning')
                .html('<i class="fas fa-times"></i> Cancelar dibujo');

            console.log('‚úèÔ∏è Modo dibujo activado para:',
                activeObject.isBall ? 'Bal√≥n' : `Jugador ${activeObject.playerNumber}`);
        }

        // Desactivar modo dibujo
        function deactivateDrawingMode() {
            isDrawingMode = false;
            currentPath = [];
            selectedForDrawing = null;

            // Restaurar cursor y canvas
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';
            canvas.selection = true;

            // Restaurar estilo del bot√≥n
            const hasSelection = canvas.getActiveObject();
            $('#btnDrawMovement').removeClass('btn-warning').addClass('btn-info')
                .html('<i class="fas fa-pencil-alt"></i> Dibujar movimiento')
                .prop('disabled', !hasSelection);

            canvas.renderAll();
        }

        // Obtener color seg√∫n tipo de objeto
        function getPathColor(obj) {
            if (obj.isBall) return '#FF8C00';  // Naranja para bal√≥n
            return '#DC3545';  // Rojo para mejor visibilidad en cancha verde
        }

        // Dibujar el path con flecha
        function createPathWithArrow(points, color) {
            if (points.length < 2) return null;

            // Crear string del path SVG
            let pathString = `M ${points[0].x} ${points[0].y}`;
            for (let i = 1; i < points.length; i++) {
                pathString += ` L ${points[i].x} ${points[i].y}`;
            }

            // Crear el path principal
            const path = new fabric.Path(pathString, {
                fill: null,
                stroke: color,
                strokeWidth: 3,
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                selectable: false,
                evented: false,
                opacity: 0.8
            });

            // Calcular √°ngulo para la flecha (√∫ltimos 2 puntos)
            const lastPoint = points[points.length - 1];
            const prevPoint = points[points.length - 2];
            const angle = Math.atan2(lastPoint.y - prevPoint.y, lastPoint.x - prevPoint.x) * 180 / Math.PI;

            // Crear tri√°ngulo de la flecha
            const arrowHead = new fabric.Triangle({
                left: lastPoint.x,
                top: lastPoint.y,
                width: 12,
                height: 15,
                fill: color,
                angle: angle + 90,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false
            });

            // Agrupar path y flecha
            const group = new fabric.Group([path, arrowHead], {
                selectable: false,
                evented: false,
                isMovement: true  // Identificador
            });

            return group;
        }

        // Guardar movimiento
        function saveMovement(obj, points, pathObject) {
            // Verificar si el jugador tiene el bal√≥n
            const hasBall = obj.isPlayer && ballPossession === obj.playerNumber;

            const movement = {
                id: ++movementIdCounter,  // ID √∫nico para eliminar correctamente
                type: 'movement',  // Tipo de acci√≥n (movement o pass)
                playerId: obj.isBall ? 'ball' : obj.playerNumber,
                playerType: obj.isBall ? 'ball' : obj.playerType,
                points: points.map(p => ({ x: Math.round(p.x), y: Math.round(p.y) })),
                hasBall: hasBall,
                pathObject: pathObject
            };

            movements.push(movement);

            // Log informativo
            if (hasBall) {
                console.log(`üíæ Movimiento guardado: J${movement.playerId} (${points.length} puntos) üèà con bal√≥n`);
            } else {
                console.log(`üíæ Movimiento guardado: J${movement.playerId} (${points.length} puntos)`);
            }
            console.log(`üí° Puedes dibujar otro movimiento para J${movement.playerId} o crear un pase`);

            // Actualizar botones y lista
            updatePlayButton();
            updatePassButton();
            renderMovementsList();

            return movement;
        }

        // Limpiar todos los movimientos y pases
        function clearAllMovements() {
            // Remover paths del canvas (solo movimientos tienen objetos visuales)
            // Los pases ya no tienen objetos visuales permanentes
            movements.forEach(action => {
                if (action.type === 'movement' && action.pathObject) {
                    canvas.remove(action.pathObject);
                }
                // type: 'pass' ya no tiene objetos visuales permanentes
            });

            movements = [];
            movementIdCounter = 0;  // Resetear contador de IDs
            canvas.renderAll();
            console.log('üßπ Trayectorias borradas');

            // Actualizar botones y lista
            updatePlayButton();
            updatePassButton();
            renderMovementsList();
        }

        // Eliminar un movimiento individual por ID √∫nico
        function deleteMovementById(id) {
            const index = movements.findIndex(m => m.id === id);
            if (index === -1) {
                console.warn(`‚ö†Ô∏è No se encontr√≥ elemento con ID ${id}`);
                return;
            }

            const action = movements[index];
            const wasPass = action.type === 'pass';

            // Si es movimiento, remover el path del canvas
            if (action.type === 'movement' && action.pathObject) {
                canvas.remove(action.pathObject);
                canvas.renderAll();
                console.log(`üóëÔ∏è Movimiento J${action.playerId} eliminado (ID: ${id})`);
            } else if (action.type === 'pass') {
                console.log(`üóëÔ∏è Pase ${action.from}‚Üí${action.to} eliminado (ID: ${id})`);
            }

            // Remover del array
            movements.splice(index, 1);

            // Si se elimin√≥ un pase, recalcular qui√©n tiene el bal√≥n
            if (wasPass) {
                recalculateBallPossession();
            }

            // Actualizar UI
            updatePlayButton();
            updatePassButton();
            renderMovementsList();
        }

        // Recalcular qui√©n tiene el bal√≥n bas√°ndose en los pases restantes
        function recalculateBallPossession() {
            const passes = movements.filter(m => m.type === 'pass');

            let newHolder;

            if (passes.length === 0) {
                // Sin pases - volver al poseedor original
                newHolder = originalBallHolder;
                console.log(`üîÑ Sin pases, bal√≥n vuelve al poseedor original: J${originalBallHolder}`);
            } else {
                // Seguir la cadena de pases para encontrar qui√©n termina con el bal√≥n
                // Construir mapa de pases
                const passMap = {};
                passes.forEach(p => {
                    passMap[p.from] = p.to;
                });

                // Empezar desde el poseedor original y seguir la cadena
                let currentHolder = originalBallHolder;
                while (passMap[currentHolder]) {
                    currentHolder = passMap[currentHolder];
                }
                newHolder = currentHolder;
                console.log(`üîÑ Recalculando cadena de pases ‚Üí bal√≥n con J${newHolder}`);
            }

            // Actualizar si cambi√≥
            if (newHolder !== ballPossession) {
                // Quitar listener del anterior
                if (ballPossession !== null) {
                    const oldPlayer = players.find(p => p.playerNumber === ballPossession);
                    if (oldPlayer) {
                        oldPlayer.off('moving');
                        oldPlayer.hasBallPossession = false;
                    }
                }

                // Asignar nuevo poseedor l√≥gico
                ballPossession = newHolder;
                const newPlayer = players.find(p => p.playerNumber === ballPossession);
                if (newPlayer) {
                    newPlayer.hasBallPossession = true;
                }

                console.log(`‚úÖ Posesi√≥n actualizada a J${ballPossession}`);
                updatePossessionUI();
            }
        }

        // Renderizar lista de movimientos en el panel
        function renderMovementsList() {
            const container = document.getElementById('movementsList');
            if (!container) return;

            if (movements.length === 0) {
                container.innerHTML = '<small class="text-muted">Sin movimientos</small>';
                return;
            }

            let html = '<div class="list-group list-group-flush">';
            movements.forEach((action) => {
                if (action.type === 'movement') {
                    const ballIcon = action.hasBall ? ' üèà' : '';
                    const ballClass = action.hasBall ? 'border-warning' : 'border-success';
                    html += `
                        <div class="list-group-item d-flex justify-content-between align-items-center py-1 px-2 ${ballClass}"
                             style="background: #2d2d2d; border-left: 3px solid; margin-bottom: 2px;">
                            <span style="color: #28a745; font-weight: bold;">
                                Jugador ${action.playerId}${ballIcon}
                            </span>
                            <button class="btn btn-sm text-danger p-0 ml-2" onclick="deleteMovementById(${action.id})" title="Eliminar movimiento">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                    `;
                } else if (action.type === 'pass') {
                    html += `
                        <div class="list-group-item d-flex justify-content-between align-items-center py-1 px-2 border-primary"
                             style="background: #1a3a5c; border-left: 3px solid; margin-bottom: 2px;">
                            <span style="color: #66b3ff; font-weight: bold;">
                                üîó Pase ${action.from}‚Üí${action.to} <small>(${action.timing || 50}%)</small>
                            </span>
                            <button class="btn btn-sm text-danger p-0 ml-2" onclick="deleteMovementById(${action.id})" title="Eliminar pase">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                        </div>
                    `;
                }
            });
            html += '</div>';

            container.innerHTML = html;
        }

        // Event handlers para dibujo
        let isMouseDown = false;

        canvas.on('mouse:down', function(opt) {
            if (!isDrawingMode) return;

            const pointer = canvas.getPointer(opt.e);

            // Verificar que empiece cerca del jugador seleccionado
            const objCenter = selectedForDrawing.getCenterPoint();
            const distance = Math.sqrt(
                Math.pow(pointer.x - objCenter.x, 2) +
                Math.pow(pointer.y - objCenter.y, 2)
            );

            if (distance > 100) {
                console.log('‚ö†Ô∏è Comienza m√°s cerca del jugador/bal√≥n (m√°x 100px)');
                return;
            }

            isMouseDown = true;
            currentPath = [{ x: pointer.x, y: pointer.y }];
        });

        canvas.on('mouse:move', function(opt) {
            if (!isDrawingMode || !isMouseDown) return;

            const pointer = canvas.getPointer(opt.e);
            const lastPoint = currentPath[currentPath.length - 1];

            // Solo agregar punto si hay suficiente distancia (suavizado)
            const distance = Math.sqrt(
                Math.pow(pointer.x - lastPoint.x, 2) +
                Math.pow(pointer.y - lastPoint.y, 2)
            );

            if (distance > 8) {
                currentPath.push({ x: pointer.x, y: pointer.y });

                // Dibujar preview temporal
                drawPreviewLine();
            }
        });

        canvas.on('mouse:up', function(opt) {
            if (!isDrawingMode || !isMouseDown) return;

            isMouseDown = false;

            // Limpiar preview
            clearPreviewLine();

            // Verificar longitud m√≠nima (solo 2 puntos necesarios)
            if (currentPath.length < 2) {
                console.log('‚ö†Ô∏è Trazo muy corto, no guardado');
                deactivateDrawingMode();
                return;
            }

            // Calcular longitud total del trazo
            let totalLength = 0;
            for (let i = 1; i < currentPath.length; i++) {
                totalLength += Math.sqrt(
                    Math.pow(currentPath[i].x - currentPath[i-1].x, 2) +
                    Math.pow(currentPath[i].y - currentPath[i-1].y, 2)
                );
            }

            if (totalLength < 10) {
                console.log('‚ö†Ô∏è Trazo muy corto (<10px), no guardado');
                deactivateDrawingMode();
                return;
            }

            // Crear path con flecha
            const color = getPathColor(selectedForDrawing);
            const pathGroup = createPathWithArrow(currentPath, color);

            if (pathGroup) {
                canvas.add(pathGroup);

                // Enviar atr√°s de los jugadores pero adelante de la cancha
                pathGroup.sendToBack();
                // Traer la cancha al fondo
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'image') {
                        obj.sendToBack();
                    }
                });

                // Guardar movimiento
                saveMovement(selectedForDrawing, currentPath, pathGroup);

                canvas.renderAll();
            }

            // Desactivar modo dibujo
            deactivateDrawingMode();
        });

        // Preview temporal mientras dibuja
        let previewLine = null;

        function drawPreviewLine() {
            clearPreviewLine();

            if (currentPath.length < 2) return;

            let pathString = `M ${currentPath[0].x} ${currentPath[0].y}`;
            for (let i = 1; i < currentPath.length; i++) {
                pathString += ` L ${currentPath[i].x} ${currentPath[i].y}`;
            }

            const color = getPathColor(selectedForDrawing);

            previewLine = new fabric.Path(pathString, {
                fill: null,
                stroke: color,
                strokeWidth: 3,
                strokeDashArray: [5, 5],
                selectable: false,
                evented: false,
                opacity: 0.6
            });

            canvas.add(previewLine);
            canvas.renderAll();
        }

        function clearPreviewLine() {
            if (previewLine) {
                canvas.remove(previewLine);
                previewLine = null;
            }
        }

        // ============================================
        // 2.7 SISTEMA DE ANIMACI√ìN
        // ============================================

        // Guardar posiciones originales de todos los objetos
        function saveOriginalPositions() {
            // Desagrupar selecci√≥n m√∫ltiple para obtener posiciones absolutas
            canvas.discardActiveObject();
            canvas.renderAll();

            originalPositions = {};

            // Guardar posiciones de jugadores
            players.forEach(p => {
                originalPositions[p.playerNumber] = {
                    left: p.left,
                    top: p.top
                };
            });

            // Guardar posici√≥n del bal√≥n
            if (rugbyBall) {
                originalPositions['ball'] = {
                    left: rugbyBall.left,
                    top: rugbyBall.top
                };
            }

            console.log('üíæ Posiciones originales guardadas:', Object.keys(originalPositions).length, 'objetos');
        }

        // Encontrar objeto por ID
        function findObjectById(id) {
            if (id === 'ball') {
                return rugbyBall;
            }
            return players.find(p => p.playerNumber === id);
        }

        // Animar un objeto siguiendo un path de puntos
        // hasBall: si es true, tambi√©n mueve el bal√≥n junto con el jugador
        function animateObjectAlongPath(obj, points, duration, callback, hasBall = false) {
            if (!obj || points.length < 2) {
                if (callback) callback();
                return;
            }

            const totalPoints = points.length;
            const timePerSegment = duration / (totalPoints - 1);
            let currentPointIndex = 0;

            function animateToNextPoint() {
                if (currentPointIndex >= totalPoints - 1) {
                    // Animaci√≥n completada
                    if (callback) callback();
                    return;
                }

                const startPoint = points[currentPointIndex];
                const endPoint = points[currentPointIndex + 1];

                // Calcular distancia para ajustar velocidad
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) +
                    Math.pow(endPoint.y - startPoint.y, 2)
                );

                // Tiempo proporcional a la distancia (m√≠nimo 20ms)
                const segmentTime = Math.max(20, timePerSegment * (distance / 20));

                // Animar hacia el siguiente punto
                fabric.util.animate({
                    startValue: 0,
                    endValue: 1,
                    duration: segmentTime,
                    easing: fabric.util.ease.easeInOutQuad,
                    onChange: function(value) {
                        const newLeft = startPoint.x + (endPoint.x - startPoint.x) * value;
                        const newTop = startPoint.y + (endPoint.y - startPoint.y) * value;

                        // Mover jugador
                        obj.set({
                            left: newLeft,
                            top: newTop
                        });
                        obj.setCoords();

                        // Si tiene bal√≥n, moverlo tambi√©n
                        if (hasBall && rugbyBall) {
                            rugbyBall.set({
                                left: newLeft + BALL_OFFSET_X,
                                top: newTop + BALL_OFFSET_Y
                            });
                            rugbyBall.dirty = true;
                            rugbyBall.setCoords();
                        }

                        canvas.renderAll();
                    },
                    onComplete: function() {
                        currentPointIndex++;
                        animateToNextPoint();
                    }
                });
            }

            // Iniciar animaci√≥n
            animateToNextPoint();
        }

        // ============================================
        // SISTEMA DE EJECUCI√ìN UNIFICADA
        // ============================================

        /**
         * NUEVO SISTEMA:
         * - TODOS los movimientos son simult√°neos
         * - Los pases ocurren DURANTE los movimientos, en el % definido
         *
         * EJEMPLO:
         * 1. Dibuja trayectorias para J9, J10, J12 (todas simult√°neas)
         * 2. Define pase 9‚Üí10 al 40%
         * 3. Define pase 10‚Üí12 al 70%
         * 4. Play: Todos corren, pases ocurren en su % definido
         */

        // Separar movimientos y pases de la lista de actions
        function getMovementsAndPasses() {
            const movementsList = movements.filter(m => m.type === 'movement');
            const passesList = movements.filter(m => m.type === 'pass');
            return { movementsList, passesList };
        }

        // Variable para rastrear qui√©n tiene el bal√≥n DURANTE la reproducci√≥n
        let playbackBallHolder = null;

        // Duraci√≥n total de la animaci√≥n (ms)
        const ANIMATION_DURATION = 3000;

        // Reproducir todos los movimientos (NUEVO: ejecuci√≥n unificada)
        function playAllMovements() {
            if (isPlaying || movements.length === 0) {
                return;
            }

            // Guardar posiciones originales solo la PRIMERA vez
            if (Object.keys(originalPositions).length === 0) {
                saveOriginalPositions();
            }

            isPlaying = true;

            // Separar movimientos y pases
            const { movementsList, passesList } = getMovementsAndPasses();

            // Determinar qui√©n tiene el bal√≥n al INICIO
            const firstPass = passesList[0];
            if (firstPass) {
                playbackBallHolder = firstPass.from;
                console.log(`üèà Poseedor inicial (del primer pase): J${playbackBallHolder}`);
            } else {
                playbackBallHolder = ballPossession;
                console.log(`üèà Poseedor inicial (actual): J${playbackBallHolder}`);
            }

            // Actualizar UI
            $('#btnPlay').prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> Reproduciendo...');
            $('#btnReset').prop('disabled', true);
            $('#btnDrawMovement').prop('disabled', true);
            $('#btnCreatePass').prop('disabled', true);

            console.log('‚ñ∂Ô∏è Iniciando reproducci√≥n UNIFICADA');
            console.log(`   üìç ${movementsList.length} movimientos simult√°neos`);
            console.log(`   üèà ${passesList.length} pases programados`);

            // Mostrar info de pases
            passesList.forEach((pass, i) => {
                const timing = pass.timing || 50;
                console.log(`      Pase ${i+1}: ${pass.from}‚Üí${pass.to} al ${timing}%`);
            });

            $('#animationStatus').html(
                `<i class="fas fa-bolt text-warning"></i> Ejecutando ${movementsList.length} movimientos + ${passesList.length} pases...`
            );

            // Programar pases para que ocurran en su % del tiempo
            // Pases al mismo timing se ejecutan en SECUENCIA (no paralelo)
            const PASS_DURATION = 800; // Duraci√≥n de cada pase en ms
            let lastTiming = -1;
            let sameTimingCount = 0;

            passesList.forEach((pass, index) => {
                const timing = Math.min(pass.timing || 50, 99); // M√°ximo 99% para evitar race condition

                // Contar cu√°ntos pases anteriores tienen el mismo timing
                if (timing === lastTiming) {
                    sameTimingCount++;
                } else {
                    sameTimingCount = 0;
                    lastTiming = timing;
                }

                // Delay base + offset para pases en secuencia
                const baseDelay = (timing / 100) * ANIMATION_DURATION;
                const sequenceOffset = sameTimingCount * (PASS_DURATION + 100); // 900ms entre pases del mismo timing
                const delay = baseDelay + sequenceOffset;

                setTimeout(() => {
                    if (isPlaying) {
                        console.log(`    üèà Ejecutando pase ${pass.from}‚Üí${pass.to} (al ${timing}%)`);
                        executePassDuringAnimation(pass);
                    }
                }, delay);
            });

            // Calcular tiempo extra necesario para pases en secuencia al final
            const passesAtEnd = passesList.filter(p => (p.timing || 50) >= 90).length;
            const extraTimeForPasses = passesAtEnd * (PASS_DURATION + 100);

            // Ejecutar todos los movimientos simult√°neamente
            playAllMovementsSimultaneously(movementsList, () => {
                // Esperar a que terminen los pases finales antes de finalizar
                setTimeout(() => {
                    finishPlayback();
                }, extraTimeForPasses);
            });
        }

        // Ejecutar pase durante la animaci√≥n (sin detener movimientos)
        function executePassDuringAnimation(passAction) {
            const fromPlayer = findObjectById(passAction.from);
            const toPlayer = findObjectById(passAction.to);

            if (!rugbyBall || !fromPlayer || !toPlayer) {
                console.error('‚ùå Error: Objetos no encontrados para el pase');
                return;
            }

            // Obtener posiciones ACTUALES (durante la animaci√≥n)
            const fromCenter = fromPlayer.getCenterPoint();
            const toCenter = toPlayer.getCenterPoint();

            // Crear flecha temporal
            const passLine = new fabric.Line([
                fromCenter.x, fromCenter.y,
                toCenter.x, toCenter.y
            ], {
                stroke: '#0066CC',
                strokeWidth: 3,
                strokeDashArray: [8, 4],
                selectable: false,
                evented: false,
                opacity: 0.9
            });

            const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x);
            const arrowHead = new fabric.Triangle({
                left: toCenter.x,
                top: toCenter.y,
                fill: '#0066CC',
                width: 15,
                height: 18,
                angle: (angle * 180 / Math.PI) + 90,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                opacity: 0.9
            });

            canvas.add(passLine, arrowHead);
            canvas.renderAll();

            // Mover bal√≥n al receptor actual
            const targetX = toCenter.x + BALL_OFFSET_X;
            const targetY = toCenter.y + BALL_OFFSET_Y;
            const startX = rugbyBall.left;
            const startY = rugbyBall.top;

            fabric.util.animate({
                startValue: 0,
                endValue: 1,
                duration: 800,  // 800ms para pase m√°s visible
                easing: fabric.util.ease.easeInOutQuad,
                onChange: function(value) {
                    rugbyBall.set({
                        left: startX + (targetX - startX) * value,
                        top: startY + (targetY - startY) * value
                    });
                    rugbyBall.dirty = true;
                    canvas.renderAll();
                },
                onComplete: function() {
                    // Eliminar flecha temporal
                    canvas.remove(passLine);
                    canvas.remove(arrowHead);

                    // Actualizar poseedor
                    playbackBallHolder = passAction.to;
                    console.log(`    ‚úì Pase completado ‚Üí J${playbackBallHolder}`);

                    canvas.renderAll();
                }
            });
        }

        // Ejecutar todos los movimientos simult√°neamente
        function playAllMovementsSimultaneously(movementsList, callback) {
            if (movementsList.length === 0) {
                callback();
                return;
            }

            const animationPromises = [];

            movementsList.forEach(movement => {
                const obj = findObjectById(movement.playerId);
                if (!obj) {
                    console.warn('‚ö†Ô∏è Objeto no encontrado:', movement.playerId);
                    return;
                }

                const promise = new Promise((resolve) => {
                    // El bal√≥n sigue din√°micamente a playbackBallHolder
                    animateObjectAlongPathUnified(obj, movement.points, ANIMATION_DURATION, () => {
                        console.log(`    ‚úì J${movement.playerId} completado`);
                        resolve();
                    }, movement.playerId);
                });

                animationPromises.push(promise);
            });

            Promise.all(animationPromises).then(() => {
                callback();
            });
        }

        // Animar objeto con seguimiento din√°mico del bal√≥n
        // DURACI√ìN FIJA: Todos los movimientos duran exactamente 'duration' ms
        function animateObjectAlongPathUnified(obj, points, duration, callback, playerId) {
            if (!obj || points.length < 2) {
                if (callback) callback();
                return;
            }

            // Calcular distancia total del trazo
            let totalDistance = 0;
            for (let i = 1; i < points.length; i++) {
                totalDistance += Math.sqrt(
                    Math.pow(points[i].x - points[i-1].x, 2) +
                    Math.pow(points[i].y - points[i-1].y, 2)
                );
            }

            const startTime = Date.now();
            const endTime = startTime + duration;

            function animate() {
                const now = Date.now();
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1); // 0 a 1

                // Calcular qu√© distancia corresponde a este progreso
                const targetDistance = progress * totalDistance;

                // Encontrar el punto en el trazo que corresponde a esta distancia
                let accumulatedDistance = 0;
                let currentPoint = points[0];

                for (let i = 1; i < points.length; i++) {
                    const segmentDistance = Math.sqrt(
                        Math.pow(points[i].x - points[i-1].x, 2) +
                        Math.pow(points[i].y - points[i-1].y, 2)
                    );

                    if (accumulatedDistance + segmentDistance >= targetDistance) {
                        // El punto est√° en este segmento
                        const segmentProgress = (targetDistance - accumulatedDistance) / segmentDistance;
                        currentPoint = {
                            x: points[i-1].x + (points[i].x - points[i-1].x) * segmentProgress,
                            y: points[i-1].y + (points[i].y - points[i-1].y) * segmentProgress
                        };
                        break;
                    }

                    accumulatedDistance += segmentDistance;
                    currentPoint = points[i];
                }

                // Mover objeto
                obj.set({ left: currentPoint.x, top: currentPoint.y });
                obj.setCoords();

                // Si ESTE jugador tiene el bal√≥n, moverlo tambi√©n
                if (playerId === playbackBallHolder && rugbyBall) {
                    rugbyBall.set({
                        left: currentPoint.x + BALL_OFFSET_X,
                        top: currentPoint.y + BALL_OFFSET_Y
                    });
                    rugbyBall.dirty = true;
                    rugbyBall.setCoords();
                }

                canvas.renderAll();

                // Continuar o terminar
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    if (callback) callback();
                }
            }

            // Iniciar animaci√≥n
            requestAnimationFrame(animate);
        }

        // Reproducir fase de movimientos simult√°neos
        function playSimultaneousPhase(actions, callback) {
            const animationPromises = [];
            const duration = 2000;

            actions.forEach(movement => {
                if (movement.type !== 'movement') return;

                const obj = findObjectById(movement.playerId);
                if (!obj) {
                    console.warn('‚ö†Ô∏è Objeto no encontrado:', movement.playerId);
                    return;
                }

                const promise = new Promise((resolve) => {
                    // DIN√ÅMICO: Calcular si tiene bal√≥n bas√°ndose en playbackBallHolder
                    // (no usar movement.hasBall que puede estar desactualizado)
                    const hasBall = (movement.playerId === playbackBallHolder);

                    if (hasBall) {
                        console.log(`    ‚Üí J${movement.playerId} se mueve CON bal√≥n üèà`);
                    }

                    animateObjectAlongPath(obj, movement.points, duration, () => {
                        console.log(`    ‚úì ${movement.playerId} completado`);
                        resolve();
                    }, hasBall);
                });

                animationPromises.push(promise);
            });

            if (animationPromises.length === 0) {
                callback();
                return;
            }

            Promise.all(animationPromises).then(() => {
                callback();
            });
        }

        // Animar un pase (bal√≥n viaja de jugador a jugador) con FLECHA TEMPORAL
        function animatePass(passAction, callback) {
            console.log(`üèà Animando pase: ${passAction.from} ‚Üí ${passAction.to}`);

            const fromPlayer = findObjectById(passAction.from);
            const toPlayer = findObjectById(passAction.to);

            if (!rugbyBall || !fromPlayer || !toPlayer) {
                console.error('‚ùå Error: Objetos no encontrados para el pase');
                callback();
                return;
            }

            // Obtener posiciones actuales
            const fromCenter = fromPlayer.getCenterPoint();
            const toCenter = toPlayer.getCenterPoint();

            // 1. CREAR FLECHA TEMPORAL
            const passLine = new fabric.Line([
                fromCenter.x, fromCenter.y,
                toCenter.x, toCenter.y
            ], {
                stroke: '#0066CC',
                strokeWidth: 3,
                strokeDashArray: [8, 4],
                selectable: false,
                evented: false,
                opacity: 0.9
            });

            // Calcular √°ngulo para la punta de flecha
            const angle = Math.atan2(
                toCenter.y - fromCenter.y,
                toCenter.x - fromCenter.x
            );

            const arrowHead = new fabric.Triangle({
                left: toCenter.x,
                top: toCenter.y,
                fill: '#0066CC',
                width: 15,
                height: 18,
                angle: (angle * 180 / Math.PI) + 90,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                opacity: 0.9
            });

            // 2. AGREGAR flecha al canvas (temporal)
            canvas.add(passLine, arrowHead);
            passLine.sendToBack();
            arrowHead.sendToBack();
            // Mantener cancha al fondo
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'image') obj.sendToBack();
            });
            canvas.renderAll();

            // Calcular posici√≥n destino del bal√≥n (donde est√° el receptor AHORA)
            const targetX = toCenter.x + BALL_OFFSET_X;
            const targetY = toCenter.y + BALL_OFFSET_Y;

            console.log(`    üèà Bal√≥n: (${rugbyBall.left.toFixed(0)},${rugbyBall.top.toFixed(0)}) ‚Üí (${targetX.toFixed(0)},${targetY.toFixed(0)})`);

            // Guardar posici√≥n inicial ANTES de animar
            const startX = rugbyBall.left;
            const startY = rugbyBall.top;

            // 3. ANIMAR BAL√ìN
            fabric.util.animate({
                startValue: 0,
                endValue: 1,
                duration: 500,  // 0.5 segundos
                easing: fabric.util.ease.easeInOutQuad,
                onChange: function(value) {
                    const newX = startX + (targetX - startX) * value;
                    const newY = startY + (targetY - startY) * value;

                    rugbyBall.set({ left: newX, top: newY });
                    rugbyBall.dirty = true;
                    rugbyBall.setCoords();
                    canvas.renderAll();
                },
                onComplete: function() {
                    // Posici√≥n final exacta
                    rugbyBall.set({ left: targetX, top: targetY });
                    rugbyBall.setCoords();

                    // 4. ELIMINAR flecha temporal
                    canvas.remove(passLine);
                    canvas.remove(arrowHead);

                    canvas.renderAll();

                    // AHORA que el bal√≥n lleg√≥ al receptor, agregar listener de movimiento
                    // para que el bal√≥n lo siga en fases posteriores
                    toPlayer.on('moving', function() {
                        if (ballPossession === this.playerNumber && rugbyBall) {
                            const center = this.getCenterPoint();
                            rugbyBall.set({
                                left: center.x + BALL_OFFSET_X,
                                top: center.y + BALL_OFFSET_Y
                            });
                            rugbyBall.dirty = true;
                            rugbyBall.setCoords();
                        }
                    });

                    console.log('    ‚úì Pase completado - bal√≥n ahora sigue a J' + toPlayer.playerNumber);
                    callback();
                }
            });
        }

        // Finalizar reproducci√≥n
        function finishPlayback() {
            isPlaying = false;
            currentAnimationIndex = 0;

            // Restaurar UI
            $('#btnPlay').prop('disabled', false).html('<i class="fas fa-play"></i> Play');
            $('#btnReset').prop('disabled', false);
            updatePlayButton();
            updatePassButton();

            $('#animationStatus').html('<i class="fas fa-check-circle text-success"></i> Reproducci√≥n completa');

            console.log('‚úÖ Reproducci√≥n completada');

            // Restaurar mensaje despu√©s de 2 segundos
            setTimeout(() => {
                if (!isPlaying) {
                    $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
                }
            }, 2000);
        }

        // Resetear a posiciones originales
        function resetToOriginalPositions() {
            if (isPlaying) {
                alert('‚ö†Ô∏è Espera a que termine la reproducci√≥n');
                return;
            }

            // Desagrupar selecci√≥n m√∫ltiple para restaurar posiciones correctamente
            canvas.discardActiveObject();
            canvas.renderAll();

            // Si no hay posiciones guardadas, guardar las actuales como referencia
            if (Object.keys(originalPositions).length === 0) {
                if (players.length === 0) {
                    alert('‚ö†Ô∏è No hay jugadores en el canvas');
                    return;
                }
                saveOriginalPositions();
                console.log('üíæ Posiciones actuales guardadas como referencia');
                $('#animationStatus').html('<i class="fas fa-save text-info"></i> Posiciones guardadas como referencia');
                setTimeout(() => {
                    $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
                }, 1500);
                return;
            }

            console.log('‚ü≤ Restaurando posiciones originales...');
            let restoredCount = 0;

            // Restaurar posiciones de jugadores
            players.forEach(p => {
                const origPos = originalPositions[p.playerNumber];
                if (origPos) {
                    console.log(`  ‚îî‚îÄ Jugador ${p.playerNumber}: (${p.left.toFixed(0)},${p.top.toFixed(0)}) ‚Üí (${origPos.left.toFixed(0)},${origPos.top.toFixed(0)})`);
                    p.set({
                        left: origPos.left,
                        top: origPos.top
                    });
                    p.dirty = true;
                    p.setCoords();
                    restoredCount++;
                }
            });

            // Restaurar posici√≥n del bal√≥n
            if (rugbyBall && originalPositions['ball']) {
                const ballOrig = originalPositions['ball'];
                console.log(`  ‚îî‚îÄ Bal√≥n: (${rugbyBall.left.toFixed(0)},${rugbyBall.top.toFixed(0)}) ‚Üí (${ballOrig.left.toFixed(0)},${ballOrig.top.toFixed(0)})`);
                rugbyBall.set({
                    left: ballOrig.left,
                    top: ballOrig.top
                });
                rugbyBall.dirty = true;
                rugbyBall.setCoords();
                restoredCount++;
            }

            // Forzar re-renderizado completo
            canvas.requestRenderAll();
            canvas.renderAll();

            console.log(`‚úÖ ${restoredCount} objetos restaurados`);

            $('#animationStatus').html(`<i class="fas fa-undo text-success"></i> ${restoredCount} posiciones restauradas`);
            setTimeout(() => {
                $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
            }, 1500);
        }

        // Actualizar estado del bot√≥n Play
        function updatePlayButton() {
            const hasMovements = movements.length > 0;
            $('#btnPlay').prop('disabled', !hasMovements || isPlaying);
        }

        // ============================================
        // 2.8 SISTEMA DE POSESI√ìN DEL BAL√ìN
        // ============================================

        // Actualizar UI de posesi√≥n
        function updatePossessionUI() {
            // Habilitar bot√≥n asignar si hay bal√≥n
            $('#btnAssignPossession').prop('disabled', !rugbyBall);

            // Mostrar/ocultar bot√≥n soltar
            if (ballPossession !== null) {
                $('#btnReleasePossession').show();
                $('#btnAssignPossession').hide();
            } else {
                $('#btnReleasePossession').hide();
                if (rugbyBall) {
                    $('#btnAssignPossession').show();
                }
            }
        }

        // Activar modo asignaci√≥n de posesi√≥n
        function activateAssignPossessionMode() {
            if (!rugbyBall) {
                alert('‚ö†Ô∏è Primero agrega un bal√≥n al canvas');
                return;
            }

            isAssigningPossession = true;
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';

            $('#btnAssignPossession')
                .removeClass('btn-outline-warning')
                .addClass('btn-warning')
                .html('<i class="fas fa-times"></i> Cancelar');

            console.log('üèà Modo asignaci√≥n: Click en un jugador para darle el bal√≥n');
        }

        // Desactivar modo asignaci√≥n
        function deactivateAssignPossessionMode() {
            isAssigningPossession = false;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';

            $('#btnAssignPossession')
                .removeClass('btn-warning')
                .addClass('btn-outline-warning')
                .html('<i class="fas fa-hand-holding"></i> Asignar posesi√≥n');
        }

        // Asignar posesi√≥n a un jugador
        function assignPossessionTo(player) {
            if (!rugbyBall || !player || !player.isPlayer) {
                console.log('‚ö†Ô∏è No se puede asignar: rugbyBall=', !!rugbyBall, 'player=', !!player);
                return;
            }

            console.log('üèà Iniciando asignaci√≥n de bal√≥n a jugador', player.playerNumber);

            // Si ya ten√≠a posesi√≥n otro jugador, quitar su listener
            if (ballPossession !== null) {
                const prevPlayer = players.find(p => p.playerNumber === ballPossession);
                if (prevPlayer) {
                    prevPlayer.off('moving');  // Quitar listener anterior
                    prevPlayer.hasBallPossession = false;
                    console.log('  ‚îî‚îÄ Removido listener del jugador anterior:', ballPossession);
                }
            }

            // Asignar nuevo poseedor
            ballPossession = player.playerNumber;
            originalBallHolder = player.playerNumber; // Guardar como poseedor original
            player.hasBallPossession = true;

            // Obtener posici√≥n real del centro del jugador
            const playerCenter = player.getCenterPoint();
            console.log('  ‚îî‚îÄ Centro del jugador:', playerCenter.x.toFixed(0), playerCenter.y.toFixed(0));

            // Guardar posici√≥n anterior del bal√≥n para debug
            const oldPos = { left: rugbyBall.left, top: rugbyBall.top };

            // MOVER BAL√ìN F√çSICAMENTE cerca del jugador
            const newLeft = playerCenter.x + BALL_OFFSET_X;
            const newTop = playerCenter.y + BALL_OFFSET_Y;

            rugbyBall.set({
                left: newLeft,
                top: newTop
            });

            // Forzar que Fabric.js reconozca el cambio
            rugbyBall.dirty = true;
            rugbyBall.setCoords();

            // Traer bal√≥n al frente para asegurar visibilidad
            canvas.bringToFront(rugbyBall);

            console.log('  ‚îî‚îÄ Bal√≥n movido de (' + oldPos.left.toFixed(0) + ',' + oldPos.top.toFixed(0) +
                ') a (' + newLeft.toFixed(0) + ',' + newTop.toFixed(0) + ')');

            // Agregar listener para cuando el jugador se mueva
            player.on('moving', function() {
                if (ballPossession === this.playerNumber && rugbyBall) {
                    const center = this.getCenterPoint();
                    rugbyBall.set({
                        left: center.x + BALL_OFFSET_X,
                        top: center.y + BALL_OFFSET_Y
                    });
                    rugbyBall.dirty = true;
                    rugbyBall.setCoords();
                }
            });

            // Forzar renderizado S√çNCRONO
            canvas.renderAll();

            updatePossessionUI();

            console.log('‚úÖ Posesi√≥n asignada a jugador', ballPossession);
        }

        // Remover listener de movimiento (sin indicador visual)
        function removePossessionListener(playerId) {
            const player = players.find(p => p.playerNumber === playerId);
            if (player) {
                player.off('moving');
                player.hasBallPossession = false;
            }
        }

        // ============================================
        // TRANSFERIR POSESI√ìN L√ìGICAMENTE (SIN MOVER BAL√ìN F√çSICO)
        // Usada al crear pases - el bal√≥n se mover√° durante Play
        // ============================================
        function transferPossessionLogically(toPlayer) {
            if (!rugbyBall || !toPlayer || !toPlayer.isPlayer) {
                console.log('‚ö†Ô∏è No se puede transferir: rugbyBall=', !!rugbyBall, 'toPlayer=', !!toPlayer);
                return;
            }

            console.log(`üîÑ Transferencia L√ìGICA de posesi√≥n a jugador ${toPlayer.playerNumber}`);
            console.log(`   ‚ö†Ô∏è El bal√≥n NO se mover√° hasta Play`);

            // Si ya ten√≠a posesi√≥n otro jugador, quitar su listener
            if (ballPossession !== null) {
                const prevPlayer = players.find(p => p.playerNumber === ballPossession);
                if (prevPlayer) {
                    prevPlayer.off('moving');  // Quitar listener anterior
                    prevPlayer.hasBallPossession = false;
                    console.log(`   ‚îî‚îÄ Removido listener del jugador anterior: ${ballPossession}`);
                }
            }

            // Asignar nuevo poseedor (SOLO L√ìGICAMENTE)
            ballPossession = toPlayer.playerNumber;
            toPlayer.hasBallPossession = true;

            // NO mover el bal√≥n f√≠sicamente
            // NO agregar listener de movimiento (el bal√≥n no est√° con √©l todav√≠a)

            // Actualizar UI
            updatePossessionUI();

            console.log(`‚úÖ Posesi√≥n L√ìGICA transferida a jugador ${ballPossession}`);
            console.log(`   üìç Bal√≥n f√≠sico sigue en: (${rugbyBall.left.toFixed(0)}, ${rugbyBall.top.toFixed(0)})`);
        }

        // Soltar bal√≥n (liberar posesi√≥n)
        function releasePossession() {
            if (ballPossession === null) {
                return;
            }

            // Quitar listener de movimiento
            removePossessionListener(ballPossession);

            // Liberar posesi√≥n
            const previousOwner = ballPossession;
            ballPossession = null;
            originalBallHolder = null; // Tambi√©n resetear poseedor original

            updatePossessionUI();
            canvas.renderAll();

            console.log('üèà Bal√≥n soltado por jugador', previousOwner);
        }

        // Limpiar posesi√≥n (para usar en clearAllPlayers)
        function clearPossession() {
            if (ballPossession !== null) {
                removePossessionListener(ballPossession);
                ballPossession = null;
            }
            originalBallHolder = null; // Tambi√©n resetear poseedor original
            updatePossessionUI();
        }

        // ============================================
        // 2.9 SISTEMA DE PASES
        // ============================================

        // Actualizar estado del bot√≥n Crear Pase
        function updatePassButton() {
            // Habilitar solo si hay bal√≥n asignado a un jugador
            const canCreatePass = ballPossession !== null && rugbyBall !== null;
            $('#btnCreatePass').prop('disabled', !canCreatePass);
        }

        // Activar modo crear pase (simplificado: origen = ballPossession autom√°tico)
        function activateCreatePassMode() {
            if (ballPossession === null) {
                alert('‚ö†Ô∏è Primero asigna el bal√≥n a un jugador');
                return;
            }

            isCreatingPass = true;
            canvas.defaultCursor = 'crosshair';
            canvas.hoverCursor = 'crosshair';

            // Cambiar estilo del bot√≥n
            $('#btnCreatePass')
                .removeClass('btn-primary')
                .addClass('btn-warning')
                .html('‚ùå Cancelar Pase');

            // Deshabilitar otros botones
            $('#btnDrawMovement').prop('disabled', true);
            $('#btnAssignPossession').prop('disabled', true);

            // Mensaje claro indicando qui√©n tiene el bal√≥n
            console.log(`üèà Modo pase activado. Jugador ${ballPossession} tiene el bal√≥n.`);
            console.log('üëâ Haz click en el jugador DESTINO del pase');

            // Mostrar mensaje visual
            showPassMessage(`Jugador ${ballPossession} pasar√°. Click en destino...`);
            $('#animationStatus').html(`<i class="fas fa-football-ball text-primary"></i> J${ballPossession} pasar√°. Click destino...`);
        }

        // Desactivar modo crear pase (con info opcional del pase creado)
        function deactivateCreatePassMode(fromPlayerId = null, toPlayerId = null, timing = null) {
            isCreatingPass = false;
            canvas.defaultCursor = 'default';
            canvas.hoverCursor = 'move';

            // Restaurar estilo del bot√≥n
            $('#btnCreatePass')
                .removeClass('btn-warning')
                .addClass('btn-primary')
                .html('üîó Crear Pase');

            // Rehabilitar botones
            const hasSelection = canvas.getActiveObject();
            $('#btnDrawMovement').prop('disabled', !hasSelection);
            updatePossessionUI();

            // Ocultar mensaje visual anterior
            hidePassMessage();

            // Mensaje informativo mejorado con tip de uso
            if (fromPlayerId && toPlayerId && timing !== null) {
                showPassMessage(
                    `‚úÖ Pase ${fromPlayerId}‚Üí${toPlayerId} al ${timing}% creado. Todos los movimientos ser√°n simult√°neos.`,
                    4000
                );
                $('#animationStatus').html(
                    `<i class="fas fa-check-circle text-success"></i> Pase al ${timing}% creado. Dibuja m√°s movimientos...`
                );
            } else {
                showPassMessage('‚úÖ Pase creado. Puedes seguir dibujando movimientos.', 3000);
                $('#animationStatus').html('<i class="fas fa-check-circle text-success"></i> Pase creado. Dibuja m√°s movimientos...');
            }

            // Restaurar mensaje despu√©s de 4 segundos
            setTimeout(() => {
                if (!isCreatingPass && !isDrawingMode) {
                    $('#animationStatus').html('<i class="fas fa-info-circle"></i> Selecciona jugador/bal√≥n primero');
                }
            }, 4000);

            console.log('üîó Modo pase desactivado');
        }

        // Mostrar mensaje flotante para pases (con duraci√≥n opcional en ms)
        function showPassMessage(text, duration = 0) {
            let messageDiv = document.getElementById('passMessage');

            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'passMessage';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 102, 204, 0.95);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: bold;
                    z-index: 9999;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    border: 2px solid white;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(messageDiv);
            }

            // Cambiar color si es mensaje de √©xito
            if (text.includes('‚úÖ')) {
                messageDiv.style.background = 'rgba(40, 167, 69, 0.95)';
            } else {
                messageDiv.style.background = 'rgba(0, 102, 204, 0.95)';
            }

            messageDiv.textContent = 'üèà ' + text;
            messageDiv.style.display = 'block';
            messageDiv.style.opacity = '1';

            // Auto-ocultar si se especifica duraci√≥n
            if (duration > 0) {
                setTimeout(() => {
                    messageDiv.style.opacity = '0';
                    setTimeout(() => {
                        messageDiv.style.display = 'none';
                    }, 300);
                }, duration);
            }
        }

        // Ocultar mensaje flotante
        function hidePassMessage() {
            const messageDiv = document.getElementById('passMessage');
            if (messageDiv) {
                messageDiv.style.display = 'none';
            }
        }

        // Crear pase entre dos jugadores (SIN objetos visuales - flecha aparece durante Play)
        function createPass(fromPlayer, toPlayer, timing = null) {
            if (!fromPlayer || !toPlayer) {
                console.error('‚ùå Error: Jugadores no v√°lidos para el pase');
                return;
            }

            // Si no se especific√≥ timing, preguntar al usuario
            if (timing === null) {
                const inputTiming = prompt(
                    `üèà Pase ${fromPlayer.playerNumber} ‚Üí ${toPlayer.playerNumber}\n\n` +
                    `¬øEn qu√© momento del movimiento ocurre el pase?\n` +
                    `(0% = inicio, 50% = mitad, 100% = final)\n\n` +
                    `Ingresa un n√∫mero entre 0 y 100:`,
                    '50'
                );

                if (inputTiming === null) {
                    console.log('‚ùå Pase cancelado');
                    return; // Usuario cancel√≥
                }

                timing = parseInt(inputTiming) || 50;
                timing = Math.max(0, Math.min(100, timing)); // Limitar 0-100
            }

            console.log(`üèà Creando pase: ${fromPlayer.playerNumber} ‚Üí ${toPlayer.playerNumber} al ${timing}%`);

            // 1. Guardar en movements[] (SIN objetos visuales)
            movements.push({
                id: ++movementIdCounter,  // ID √∫nico para eliminar correctamente
                type: 'pass',
                from: fromPlayer.playerNumber,
                to: toPlayer.playerNumber,
                timing: timing  // Porcentaje del momento del pase
            });

            // 2. Transferir posesi√≥n L√ìGICAMENTE al receptor (SIN mover bal√≥n f√≠sico)
            // El bal√≥n se mover√° durante la animaci√≥n (Play)
            transferPossessionLogically(toPlayer);

            console.log(`‚úÖ Pase creado al ${timing}% (flecha se mostrar√° durante Play)`);
            console.log(`üí° Tip: Ahora puedes dibujar m√°s movimientos para J${fromPlayer.playerNumber} o J${toPlayer.playerNumber}`);

            // Actualizar botones y lista
            updatePlayButton();
            updatePassButton();
            renderMovementsList();

            canvas.renderAll();

            return timing; // Retornar para mostrar en mensaje
        }

        // ============================================
        // 3. ELIMINAR JUGADOR SELECCIONADO
        // ============================================
        function deleteSelectedPlayer() {
            const activeObject = canvas.getActiveObject();

            if (activeObject && activeObject.isPlayer) {
                canvas.remove(activeObject);
                players = players.filter(p => p !== activeObject);
                selectedPlayer = null;
                canvas.renderAll();
            } else if (activeObject && activeObject.isBall) {
                // Eliminar bal√≥n si est√° seleccionado
                eliminarBalon();
            } else {
                alert('‚ö†Ô∏è Selecciona un jugador o bal√≥n primero (click sobre √©l)');
            }
        }

        // ============================================
        // 4. LIMPIAR JUGADORES
        // ============================================
        function clearAllPlayers() {
            players.forEach(player => canvas.remove(player));
            players = [];
            playerCounter = 1;
            selectedPlayer = null;
            // Tambi√©n eliminar el bal√≥n
            eliminarBalon();
            // Tambi√©n limpiar movimientos/trayectorias
            clearAllMovements();
            canvas.renderAll();
        }

        // ============================================
        // 5. FORMACIONES PREDEFINIDAS
        // ============================================
        function applyFormacion() {
            const formacion = $('#formacionSelect').val();

            if (!formacion) {
                alert('‚ö†Ô∏è Selecciona una formaci√≥n primero');
                return;
            }

            clearAllPlayers();

            switch(formacion) {
                case 'scrum':
                    formacionScrum();
                    break;
                case 'lineout':
                    formacionLineout();
                    break;
                case 'lineout_completo':
                    formacionLineoutCompleto();
                    break;
                case 'ruck':
                    formacionRuck();
                    break;
                case 'maul':
                    formacionMaul();
                    break;
                case 'backs':
                    formacionBacks();
                    break;
                case 'kickoff':
                    formacionKickoff();
                    break;
                case 'full15':
                    formacionFull15();
                    break;
            }

            // Guardar posiciones originales despu√©s de aplicar formaci√≥n
            setTimeout(() => {
                saveOriginalPositions();
            }, 100);
        }

        // ============== FORMACIONES FORWARDS ==============

        // Scrum 3-4-1 (atacando de izquierda ‚Üí derecha)
        function formacionScrum() {
            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  SCRUM 3-4-1 - Atacando IZQUIERDA ‚Üí DERECHA              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                            ‚ïë
‚ïë  ATR√ÅS (izquierda)              ADELANTE (derecha)        ‚ïë
‚ïë                                                            ‚ïë
‚ïë                        6                1                  ‚ïë
‚ïë                        4                2                  ‚ïë
‚ïë    9 ‚îÄ‚îÄ 8                                                  ‚ïë
‚ïë                        5                3                  ‚ïë
‚ïë                        7                                   ‚ïë
‚ïë                                                            ‚ïë
‚ïë  Direcci√≥n de ataque:  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫              ‚ïë
‚ïë                                                            ‚ïë
‚ïë  1,2,3 = Primera l√≠nea (m√°s adelante)                     ‚ïë
‚ïë  4,5 = Segunda l√≠nea                                       ‚ïë
‚ïë  6 = Flanker (arriba del 4, misma columna)                ‚ïë
‚ïë  7 = Flanker (abajo del 5, misma columna)                 ‚ïë
‚ïë  8 = Octavo (cerca del 9)                                  ‚ïë
‚ïë  9 = Medio scrum                                           ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            `);

            const baseX = 350;
            const baseY = 325;

            // Medio scrum (alejado) y Octavo (pegado al scrum)
            addPlayer('back', baseX - 50, baseY, 9);
            addPlayer('forward', baseX + 70, baseY, 8);

            // SEGUNDA l√≠nea (segundas l√≠neas)
            addPlayer('forward', baseX + 110, baseY - 20, 4);
            addPlayer('forward', baseX + 110, baseY + 20, 5);

            // TERCERA l√≠nea (flankers) - misma columna X que 4 y 5
            addPlayer('forward', baseX + 110, baseY - 55, 6);  // Flanker arriba del 4
            addPlayer('forward', baseX + 110, baseY + 55, 7);  // Flanker abajo del 5

            // PRIMERA l√≠nea (pegada a la segunda)
            addPlayer('forward', baseX + 150, baseY - 35, 1);  // Pilar arriba
            addPlayer('forward', baseX + 150, baseY, 2);       // Hooker centro
            addPlayer('forward', baseX + 150, baseY + 35, 3);  // Pilar abajo

            playerCounter = 10;
        }

        // Lineout 5 jugadores (simplificado)
        function formacionLineout() {
            const baseX = 500;
            const startY = 180;
            const spacing = 75;

            // L√≠nea vertical de forwards en el lateral (5 saltadores)
            addPlayer('forward', baseX, startY, 4);           // 1er saltador
            addPlayer('forward', baseX, startY + spacing, 5); // 2do saltador
            addPlayer('forward', baseX, startY + spacing * 2, 6); // 3er saltador
            addPlayer('forward', baseX, startY + spacing * 3, 7); // 4to saltador
            addPlayer('forward', baseX, startY + spacing * 4, 2); // Hooker

            // Medio scrum ATR√ÅS esperando el bal√≥n (m√°s a la izquierda)
            addPlayer('back', baseX - 100, startY + spacing * 2, 9);

            playerCounter = 10;
        }

        // Lineout completo (8 forwards)
        function formacionLineoutCompleto() {
            const baseX = 550;
            const startY = 130;
            const spacing = 60;

            // L√≠nea de lineout (8 forwards) en el lateral
            addPlayer('forward', baseX, startY, 1);
            addPlayer('forward', baseX, startY + spacing, 4);
            addPlayer('forward', baseX, startY + spacing * 2, 5);
            addPlayer('forward', baseX, startY + spacing * 3, 6);
            addPlayer('forward', baseX, startY + spacing * 4, 7);
            addPlayer('forward', baseX, startY + spacing * 5, 8);
            addPlayer('forward', baseX, startY + spacing * 6, 3);
            addPlayer('forward', baseX, startY + spacing * 7, 2); // Hooker

            // Medio scrum ATR√ÅS (m√°s a la izquierda)
            addPlayer('back', baseX - 100, startY + spacing * 3.5, 9);

            playerCounter = 10;
        }

        // Ruck - Agrupamiento tras tackle (basado en imagen proporcionada)
        function formacionRuck() {
            // === FULLBACK - MUY ATR√ÅS (alineado con 10) ===
            addPlayer('back', 350, 305, 15);

            // === WINGS Y BACKS PROFUNDOS ===
            addPlayer('back', 470, 50, 11);       // Wing arriba
            addPlayer('back', 530, 130, 13);      // Centro ext
            addPlayer('back', 560, 560, 14);      // Wing abajo

            // === BACKS SOPORTE MEDIO ===
            addPlayer('back', 590, 220, 12);      // Centro int
            addPlayer('back', 650, 305, 10);      // Apertura

            // === FORWARDS ATR√ÅS DEL RUCK ===
            addPlayer('forward', 680, 450, 1);    // Prop
            addPlayer('forward', 680, 500, 2);    // Hooker

            // === EL RUCK (agrupamiento central) ===
            addPlayer('forward', 740, 220, 4);    // Lock - adelante
            addPlayer('forward', 710, 270, 3);    // Prop - atr√°s
            addPlayer('forward', 710, 195, 5);    // Lock - atr√°s

            // === FORWARDS ADELANTE (derecha del ruck) ===
            addPlayer('back', 830, 390, 9);       // Medio scrum
            addPlayer('forward', 880, 385, 8);    // N√∫mero 8
            addPlayer('forward', 920, 360, 7);    // Flanker
            addPlayer('forward', 920, 430, 6);    // Flanker - alineado con 7

            playerCounter = 16;
        }

        // Maul - Forwards agrupados pero separados, backs espaciados
        function formacionMaul() {
            // === BACKS ESPACIADOS (igual que formaci√≥n 15 jugadores) ===
            addPlayer('back', 370, 340, 15);     // Fullback izquierda
            addPlayer('back', 490, 70, 11);      // Wing arriba
            addPlayer('back', 550, 150, 13);     // Centro ext
            addPlayer('back', 580, 235, 12);     // Centro int
            addPlayer('back', 640, 300, 10);     // Apertura
            addPlayer('back', 580, 550, 14);     // Wing abajo

            // === EL MAUL - FORWARDS AGRUPADOS PERO M√ÅS SEPARADOS ===
            addPlayer('back', 710, 400, 9);      // Medio scrum (borde izq maul)
            addPlayer('forward', 750, 395, 8);   // N√∫mero 8 (centro-izq)
            addPlayer('forward', 770, 360, 1);   // Prop (arriba-centro)
            addPlayer('forward', 780, 410, 2);   // Hooker (centro)
            addPlayer('forward', 770, 460, 6);   // Flanker (abajo-centro)
            addPlayer('forward', 810, 340, 4);   // Lock (arriba-der)
            addPlayer('forward', 820, 390, 5);   // Lock (centro-der)
            addPlayer('forward', 830, 440, 7);   // Flanker (abajo-der)
            addPlayer('forward', 850, 415, 3);   // Prop (extremo der)

            playerCounter = 16;
        }

        // ============== SITUACIONES ESPECIALES ==============

        // Kick-off - Formaci√≥n de recepci√≥n (basada en imagen de referencia)
        function formacionKickoff() {
            // === JUGADORES SUPERIORES (arriba de la cancha) ===
            addPlayer('back', 380, 80, 11);      // Wing izquierdo arriba
            addPlayer('back', 750, 140, 14);     // Wing derecho arriba

            // === SEGUNDA L√çNEA ===
            addPlayer('back', 380, 190, 13);     // Centro exterior
            addPlayer('back', 750, 230, 12);     // Centro interior

            // === TERCERA L√çNEA / ZONA CENTRAL ===
            addPlayer('back', 180, 280, 15);     // Fullback izquierda profundo
            addPlayer('back', 550, 280, 10);     // Apertura

            // === AGRUPAMIENTO CENTRAL (FORWARDS) ===
            addPlayer('forward', 650, 380, 1);   // Prop
            addPlayer('forward', 680, 410, 2);   // Hooker
            addPlayer('forward', 710, 380, 3);   // Prop
            addPlayer('forward', 780, 400, 4);   // Lock
            addPlayer('forward', 820, 370, 5);   // Lock

            // === ZONA INFERIOR DISPERSA ===
            addPlayer('back', 380, 420, 9);      // Medio scrum
            addPlayer('forward', 620, 480, 6);   // Flanker
            addPlayer('forward', 750, 480, 7);   // Flanker
            addPlayer('forward', 380, 540, 8);   // N√∫mero 8

            playerCounter = 16;
        }

        // ============== FORMACIONES BACKS ==============

        // Backs en l√≠nea de ataque (profundidad correcta, atacando izquierda ‚Üí derecha)
        function formacionBacks() {
            const baseX = 500;  // 9 m√°s adelante (cerca del scrum)
            const baseY = 325;

            // 9 m√°s ADELANTE (derecha) - recibe del 8
            addPlayer('back', baseX, baseY, 9);

            // 10 detr√°s del 9, un poco arriba
            addPlayer('back', baseX - 60, baseY - 50, 10);

            // 12 detr√°s del 10
            addPlayer('back', baseX - 120, baseY - 100, 12);

            // 13 detr√°s del 12
            addPlayer('back', baseX - 180, baseY - 150, 13);

            // 11 wing arriba (extremo, m√°s atr√°s)
            addPlayer('back', baseX - 240, baseY - 200, 11);

            // 15 fullback detr√°s del 9 como apoyo
            addPlayer('back', baseX - 60, baseY + 50, 15);

            // 14 wing abajo (extremo)
            addPlayer('back', baseX - 180, baseY + 150, 14);

            playerCounter = 16;
        }

        // ============== FORMACIONES COMPLETAS ==============

        // 15 jugadores completos (Scrum + Backs en l√≠nea de ataque)
        function formacionFull15() {
            const scrumX = 750;
            const scrumY = 420;  // Scrum un poco m√°s arriba
            const backsY = 320;  // Backs arriba

            // === FORWARDS ADELANTE (derecha) - Scrum m√°s abajo ===
            // Primera l√≠nea (m√°s adelante)
            addPlayer('forward', scrumX, scrumY - 35, 1);
            addPlayer('forward', scrumX, scrumY, 2);
            addPlayer('forward', scrumX, scrumY + 35, 3);

            // Segunda l√≠nea + Flankers (misma l√≠nea X, m√°s separados)
            addPlayer('forward', scrumX - 40, scrumY - 55, 6);
            addPlayer('forward', scrumX - 40, scrumY - 20, 4);
            addPlayer('forward', scrumX - 40, scrumY + 20, 5);
            addPlayer('forward', scrumX - 40, scrumY + 55, 7);

            // Octavo (m√°s cerca del scrum)
            addPlayer('forward', scrumX - 70, scrumY, 8);

            // === BACKS ATR√ÅS (izquierda) - Arriba en la cancha ===
            // 9 detr√°s del 8 (m√°s cerca)
            addPlayer('back', scrumX - 120, scrumY, 9);

            // 10 detr√°s del 9, arriba
            addPlayer('back', scrumX - 230, backsY, 10);

            // 12 detr√°s del 10 (menos profundo)
            addPlayer('back', scrumX - 280, backsY - 70, 12);

            // 13 detr√°s del 12 (menos profundo)
            addPlayer('back', scrumX - 330, backsY - 140, 13);

            // 11 wing arriba (extremo)
            addPlayer('back', scrumX - 380, backsY - 210, 11);

            // 15 fullback m√°s atr√°s que el 11
            addPlayer('back', scrumX - 430, backsY, 15);

            // 14 wing abajo
            addPlayer('back', scrumX - 330, scrumY + 100, 14);

            playerCounter = 16;
        }

        // ============================================
        // 6. GUARDAR JUGADA
        // ============================================
        function savePlay() {
            const playName = $('#playNameInput').val().trim();
            const playCategory = $('#playCategory').val();

            if (!playName) {
                alert('‚ö†Ô∏è Ingresa un nombre para la jugada');
                return;
            }

            if (players.length === 0) {
                alert('‚ö†Ô∏è Agrega al menos un jugador antes de guardar');
                return;
            }

            // Extraer datos simples de los jugadores
            const playersData = players.map(p => ({
                number: p.playerNumber,
                type: p.playerType,
                x: Math.round(p.left),
                y: Math.round(p.top)
            }));

            // Crear thumbnail
            const thumbnail = canvas.toDataURL({ format: 'png', quality: 0.6 });

            // Determinar icono de categor√≠a
            const categoryIcon = {
                'forwards': 'üü£',
                'backs': 'üü¢',
                'full_team': '‚ö™'
            }[playCategory] || '‚ö™';

            // Extraer datos del bal√≥n si existe
            const ballData = rugbyBall ? {
                x: Math.round(rugbyBall.left),
                y: Math.round(rugbyBall.top),
                isBall: true
            } : null;

            // Extraer datos de movimientos y pases (sin objetos Fabric no serializables)
            const movementsData = movements.map(action => {
                if (action.type === 'movement') {
                    return {
                        type: 'movement',
                        playerId: action.playerId,
                        playerType: action.playerType,
                        points: action.points,
                        hasBall: action.hasBall || false
                    };
                } else if (action.type === 'pass') {
                    return {
                        type: 'pass',
                        from: action.from,
                        to: action.to
                    };
                }
                return action;
            });

            // Crear objeto de jugada
            const play = {
                id: Date.now(),
                name: playName,
                category: playCategory,
                categoryIcon: categoryIcon,
                players: playersData,
                ball: ballData,  // Incluir bal√≥n
                ballPossession: ballPossession,  // Qui√©n tiene el bal√≥n actualmente
                originalBallHolder: originalBallHolder,  // Qui√©n tuvo el bal√≥n originalmente
                movements: movementsData,  // Incluir movimientos
                thumbnail: thumbnail,
                created_at: new Date().toISOString()
            };

            // Guardar en localStorage
            let plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            plays.push(play);
            localStorage.setItem('rugbyPlays', JSON.stringify(plays));

            $('#playNameInput').val('');
            loadPlays();

            alert(`‚úÖ Jugada guardada: ${playName} (${categoryIcon} ${playCategory})`);
        }

        // ============================================
        // 7. CARGAR JUGADAS
        // ============================================
        function loadPlays() {
            const plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            const container = $('#savedPlaysList');

            if (plays.length === 0) {
                container.html('<p class="text-muted text-center small mb-0"><i class="fas fa-info-circle"></i> Sin jugadas</p>');
                $('#playCount').text('0');
                return;
            }

            $('#playCount').text(plays.length);

            let html = '';
            plays.reverse().forEach(play => {
                const date = new Date(play.created_at).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' });
                const categoryIcon = play.categoryIcon || '‚ö™';
                const categoryLabel = play.category ? play.category.replace('_', ' ') : 'general';

                html += `
                    <div class="saved-play-item">
                        <strong>${categoryIcon} ${play.name}</strong><br>
                        <small class="text-muted">
                            ${play.players.length} jug. ¬∑ ${date}
                        </small>
                        <div class="mt-1">
                            <button class="btn btn-sm btn-info load-play" data-id="${play.id}" title="Cargar">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button class="btn btn-sm btn-danger delete-play" data-id="${play.id}" title="Eliminar">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

            container.html(html);
        }

        // ============================================
        // 8. CARGAR JUGADA ESPEC√çFICA
        // ============================================
        $(document).on('click', '.load-play', function() {
            const playId = $(this).data('id');
            const plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            const play = plays.find(p => p.id === playId);

            if (!play) {
                alert('‚ùå Jugada no encontrada');
                return;
            }

            clearAllPlayers();

            // Recrear jugadores desde los datos guardados
            play.players.forEach(p => {
                addPlayer(p.type, p.x, p.y, p.number);
            });

            // Restaurar bal√≥n si exist√≠a
            if (play.ball && play.ball.isBall) {
                crearBalon(play.ball.x, play.ball.y);
            }

            // Restaurar movimientos y pases si exist√≠an
            if (play.movements && play.movements.length > 0) {
                play.movements.forEach(action => {
                    if (action.type === 'movement' || !action.type) {
                        // Es un movimiento (compatibilidad con datos antiguos sin type)
                        let color;
                        if (action.playerType === 'ball') {
                            color = '#FF8C00';
                        } else if (action.playerType === 'forward') {
                            color = '#1e4d2b';
                        } else {
                            color = '#28a745';
                        }

                        // Recrear path con flecha
                        const pathGroup = createPathWithArrow(action.points, color);
                        if (pathGroup) {
                            canvas.add(pathGroup);
                            pathGroup.sendToBack();

                            // Guardar en array de movimientos con ID √∫nico
                            movements.push({
                                id: ++movementIdCounter,
                                type: 'movement',
                                playerId: action.playerId,
                                playerType: action.playerType,
                                points: action.points,
                                hasBall: action.hasBall || false,
                                pathObject: pathGroup
                            });
                        }
                    } else if (action.type === 'pass') {
                        // Es un pase - solo guardar datos (sin visual, flecha aparece durante Play)
                        movements.push({
                            id: ++movementIdCounter,
                            type: 'pass',
                            from: action.from,
                            to: action.to
                            // Sin objetos visuales - la flecha se crea durante animaci√≥n
                        });
                    }
                });

                // Enviar cancha al fondo
                canvas.getObjects().forEach(obj => {
                    if (obj.type === 'image') {
                        obj.sendToBack();
                    }
                });

                canvas.renderAll();

                // Actualizar botones
                updatePlayButton();
                updatePassButton();
            }

            // Restaurar posesi√≥n del bal√≥n si exist√≠a
            if (play.ballPossession !== null && play.ballPossession !== undefined) {
                // Primero restaurar el poseedor original (el que tuvo el bal√≥n antes de pases)
                const originalHolder = play.originalBallHolder || play.ballPossession;
                const playerOriginal = players.find(p => p.playerNumber === originalHolder);
                if (playerOriginal && rugbyBall) {
                    assignPossessionTo(playerOriginal); // Esto setea originalBallHolder
                }

                // Si hay pases, actualizar ballPossession al receptor final
                if (play.ballPossession !== originalHolder) {
                    ballPossession = play.ballPossession;
                    const finalHolder = players.find(p => p.playerNumber === play.ballPossession);
                    if (finalHolder) {
                        finalHolder.hasBallPossession = true;
                    }
                }
            }

            // Guardar posiciones originales al cargar
            saveOriginalPositions();

            // Actualizar UI de posesi√≥n
            updatePossessionUI();

            $('#playNameInput').val(play.name);

            alert('‚úÖ Jugada cargada: ' + play.name);
        });

        // ============================================
        // 9. ELIMINAR JUGADA
        // ============================================
        $(document).on('click', '.delete-play', function() {
            const playId = $(this).data('id');

            if (!confirm('¬øEliminar esta jugada?')) return;

            let plays = JSON.parse(localStorage.getItem('rugbyPlays') || '[]');
            plays = plays.filter(p => p.id !== playId);
            localStorage.setItem('rugbyPlays', JSON.stringify(plays));

            loadPlays();
        });

        // ============================================
        // 10. LIMPIAR CANVAS COMPLETO
        // ============================================
        function clearCanvas() {
            if (players.length === 0) {
                alert('‚ö†Ô∏è El canvas ya est√° vac√≠o');
                return;
            }

            if (confirm('¬øLimpiar toda la cancha y jugadores?')) {
                clearAllPlayers();
            }
        }

        // ============================================
        // 11. EVENT LISTENERS
        // ============================================
        $('#btnAddPlayer').on('click', () => addPlayer());
        $('#btnAddBall').on('click', () => crearBalon());
        $('#btnDeleteSelected').on('click', deleteSelectedPlayer);
        $('#btnApplyFormacion').on('click', applyFormacion);
        $('#btnSavePlay').on('click', savePlay);
        $('#btnClearCanvas').on('click', clearCanvas);

        // Botones de trayectorias
        $('#btnDrawMovement').on('click', function() {
            if (isDrawingMode) {
                deactivateDrawingMode();
            } else {
                activateDrawingMode();
            }
        });

        $('#btnClearMovements').on('click', function() {
            if (movements.length === 0) {
                alert('‚ö†Ô∏è No hay trayectorias para borrar');
                return;
            }
            if (confirm('¬øBorrar todas las trayectorias?')) {
                clearAllMovements();
                updatePlayButton();
            }
        });

        // Botones de animaci√≥n
        $('#btnPlay').on('click', function() {
            if (!isPlaying && movements.length > 0) {
                playAllMovements();
            }
        });

        $('#btnReset').on('click', function() {
            resetToOriginalPositions();
        });

        // Botones de posesi√≥n del bal√≥n
        $('#btnAssignPossession').on('click', function() {
            if (isAssigningPossession) {
                deactivateAssignPossessionMode();
            } else {
                activateAssignPossessionMode();
            }
        });

        $('#btnReleasePossession').on('click', function() {
            releasePossession();
        });

        // Bot√≥n crear pase
        $('#btnCreatePass').on('click', function() {
            if (isCreatingPass) {
                deactivateCreatePassMode();
            } else {
                activateCreatePassMode();
            }
        });

        // Handler para asignar posesi√≥n y crear pases al hacer click en jugador
        canvas.on('mouse:down', function(opt) {
            const target = opt.target;

            // Modo asignar posesi√≥n
            if (isAssigningPossession) {
                if (target && target.isPlayer) {
                    assignPossessionTo(target);
                    deactivateAssignPossessionMode();
                }
                return;
            }

            // Modo crear pase - se maneja en mouse:up para evitar arrastre
            if (isCreatingPass) {
                return; // No hacer nada en mouse:down, esperar mouse:up
            }
        });

        // Handler para crear pases en mouse:up (evita que el jugador quede "pegado")
        canvas.on('mouse:up', function(opt) {
            if (!isCreatingPass) return;

            const target = opt.target;
            if (target && target.isPlayer) {
                const destinationPlayer = target;

                // Validar que no sea el mismo jugador
                if (destinationPlayer.playerNumber === ballPossession) {
                    alert('‚ö†Ô∏è No puedes pasar a ti mismo.\n\nSelecciona otro jugador como destino.');
                    return;
                }

                // Buscar jugador origen (el que tiene el bal√≥n)
                const originPlayer = findObjectById(ballPossession);

                if (!originPlayer) {
                    alert('‚ö†Ô∏è Error: No se encontr√≥ el jugador con bal√≥n');
                    deactivateCreatePassMode();
                    return;
                }

                // Guardar IDs antes de crear el pase (para mostrar tip)
                const fromId = originPlayer.playerNumber;
                const toId = destinationPlayer.playerNumber;

                // Deseleccionar para evitar problemas
                canvas.discardActiveObject();
                canvas.renderAll();

                // CREAR EL PASE (pide timing al usuario)
                const timing = createPass(originPlayer, destinationPlayer);

                // Si el usuario cancel√≥, no desactivar modo
                if (timing === undefined) {
                    return;
                }

                // Desactivar modo (pasar IDs y timing para mostrar tip informativo)
                deactivateCreatePassMode(fromId, toId, timing);
            }
        });

        // Habilitar/deshabilitar bot√≥n de dibujo seg√∫n selecci√≥n
        canvas.on('selection:created', function(e) {
            const obj = e.selected[0];
            if (obj && (obj.isPlayer || obj.isBall)) {
                $('#btnDrawMovement').prop('disabled', false);
            }
        });

        canvas.on('selection:updated', function(e) {
            const obj = e.selected[0];
            if (obj && (obj.isPlayer || obj.isBall)) {
                $('#btnDrawMovement').prop('disabled', false);
            }
        });

        // Deseleccionar al hacer click en el fondo
        canvas.on('selection:cleared', function() {
            selectedPlayer = null;
            if (!isDrawingMode) {
                $('#btnDrawMovement').prop('disabled', true);
            }
        });

        // ============================================
        // 12. INICIALIZACI√ìN
        // ============================================
        $(document).ready(function() {
            drawRugbyField();
            loadPlays();

            console.log('‚úÖ Editor de Jugadas Rugby - FASE 2 Inicializado');
            console.log('üèâ Funcionalidades: Posiciones fijas, formaciones, guardar/cargar');
            console.log('üèà Bal√≥n: Agregar, arrastrar, eliminar, posesi√≥n');
            console.log('‚úèÔ∏è Trayectorias: Dibujar movimientos para jugadores/bal√≥n');
            console.log('üîó Pases: Crear pases entre jugadores con flecha azul');
            console.log('‚ñ∂Ô∏è Animaci√≥n: Sistema de fases (movimientos simult√°neos + pases secuenciales)');
            console.log('üìê Orientaci√≥n: Izquierda ‚Üí Derecha');
        });
    </script>
</body>
</html>
